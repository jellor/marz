// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Im.Base.proto

#ifndef PROTOBUF_Im_2eBase_2eproto__INCLUDED
#define PROTOBUF_Im_2eBase_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Im {
namespace Base {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Im_2eBase_2eproto();
void protobuf_AssignDesc_Im_2eBase_2eproto();
void protobuf_ShutdownFile_Im_2eBase_2eproto();

class IpAddr;
class UserInfo;
class ContactSessionInfo;
class UserStatus;
class ServerUserStatus;
class UnreadInfo;
class MsgInfo;
class GroupVersionInfo;
class GroupInfo;
class UserTokenInfo;
class PushResult;
class ShieldStatus;
class OfflineFileInfo;

enum Service {
  SERVICE_LOGIN = 1,
  SERVICE_BUDDY_LIST = 2,
  SERVICE_MESSAGE = 3,
  SERVICE_GROUP = 4,
  SERVICE_FILE = 5,
  SERVICE_SWITCH_SERVICE = 6,
  SERVICE_INTERNAL = 7,
  SERVICE_OTHER = 8,
  SERVICE_RELATION = 9,
  SERVICE_USER = 10,
  SERVICE_SESSION = 11
};
bool Service_IsValid(int value);
const Service Service_MIN = SERVICE_LOGIN;
const Service Service_MAX = SERVICE_SESSION;
const int Service_ARRAYSIZE = Service_MAX + 1;

const ::google::protobuf::EnumDescriptor* Service_descriptor();
inline const ::std::string& Service_Name(Service value) {
  return ::google::protobuf::internal::NameOfEnum(
    Service_descriptor(), value);
}
inline bool Service_Parse(
    const ::std::string& name, Service* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Service>(
    Service_descriptor(), name, value);
}
enum LoginCommand {
  REQ_MSG_SERVER = 257,
  RES_MSG_SERVER = 258,
  REQ_USER_LOGIN = 259,
  RES_USER_LOGIN = 260,
  REQ_USER_LOGOUT = 261,
  RES_USER_LOGOUT = 262,
  KICK_USER = 263,
  REQ_DEVICE_TOKEN = 264,
  RES_DEVICE_TOKEN = 265,
  REQ_VALIDATE = 266,
  RES_VALIDATE = 267
};
bool LoginCommand_IsValid(int value);
const LoginCommand LoginCommand_MIN = REQ_MSG_SERVER;
const LoginCommand LoginCommand_MAX = RES_VALIDATE;
const int LoginCommand_ARRAYSIZE = LoginCommand_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginCommand_descriptor();
inline const ::std::string& LoginCommand_Name(LoginCommand value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginCommand_descriptor(), value);
}
inline bool LoginCommand_Parse(
    const ::std::string& name, LoginCommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginCommand>(
    LoginCommand_descriptor(), name, value);
}
enum BuddyListCommand {
  REQ_RECENT_CONTACT_SESSION = 513,
  RES_RECENT_CONTACT_SESSION = 514,
  STATUS_NOTIFY = 515,
  REQ_USERS_STATUS = 522,
  RES_USERS_STATUS = 523,
  REQ_CHANGE_AVATAR = 524,
  RES_CHANGE_AVATAR = 525
};
bool BuddyListCommand_IsValid(int value);
const BuddyListCommand BuddyListCommand_MIN = REQ_RECENT_CONTACT_SESSION;
const BuddyListCommand BuddyListCommand_MAX = RES_CHANGE_AVATAR;
const int BuddyListCommand_ARRAYSIZE = BuddyListCommand_MAX + 1;

const ::google::protobuf::EnumDescriptor* BuddyListCommand_descriptor();
inline const ::std::string& BuddyListCommand_Name(BuddyListCommand value) {
  return ::google::protobuf::internal::NameOfEnum(
    BuddyListCommand_descriptor(), value);
}
inline bool BuddyListCommand_Parse(
    const ::std::string& name, BuddyListCommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuddyListCommand>(
    BuddyListCommand_descriptor(), name, value);
}
enum MessageCommand {
  MSG_DATA = 769,
  MSG_DATA_ACK = 770,
  MSG_READ_ACK = 771,
  MSG_READ_NOTIFY = 772,
  REQ_MSG_TIME = 773,
  RES_MSG_TIME = 774,
  REQ_UNREAD_COUNT = 775,
  RES_UNREAD_COUNT = 776,
  REQ_MSG_LIST = 777,
  RES_MSG_LIST = 778,
  REQ_LATEST_MSG_ID = 779,
  RES_LATEST_MSG_ID = 780,
  REQ_MSG_BY_MSG_ID = 781,
  RES_MSG_BY_MSG_ID = 782
};
bool MessageCommand_IsValid(int value);
const MessageCommand MessageCommand_MIN = MSG_DATA;
const MessageCommand MessageCommand_MAX = RES_MSG_BY_MSG_ID;
const int MessageCommand_ARRAYSIZE = MessageCommand_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageCommand_descriptor();
inline const ::std::string& MessageCommand_Name(MessageCommand value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageCommand_descriptor(), value);
}
inline bool MessageCommand_Parse(
    const ::std::string& name, MessageCommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageCommand>(
    MessageCommand_descriptor(), name, value);
}
enum GroupCommand {
  REQ_NORMAL_LIST = 1025,
  RES_NORMAL_LIST = 1026,
  REQ_GROUP_INFO = 1027,
  RES_GROUP_INFO = 1028,
  REQ_CREATE_GROUP = 1029,
  RES_CREATE_GROUP = 1030,
  REQ_CHANGE_GROUP_MEMBER = 1031,
  RES_CHANGE_GROUP_MEMBER = 1032,
  REQ_SHIELD_GROUP = 1033,
  RES_SHIELD_GROUP = 1034,
  CHANGE_MEMBER_NOTIFY = 1035
};
bool GroupCommand_IsValid(int value);
const GroupCommand GroupCommand_MIN = REQ_NORMAL_LIST;
const GroupCommand GroupCommand_MAX = CHANGE_MEMBER_NOTIFY;
const int GroupCommand_ARRAYSIZE = GroupCommand_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupCommand_descriptor();
inline const ::std::string& GroupCommand_Name(GroupCommand value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupCommand_descriptor(), value);
}
inline bool GroupCommand_Parse(
    const ::std::string& name, GroupCommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupCommand>(
    GroupCommand_descriptor(), name, value);
}
enum FileCommand {
  REQ_FILE_LOGIN = 1281,
  RES_FILE_LOGIN = 1282
};
bool FileCommand_IsValid(int value);
const FileCommand FileCommand_MIN = REQ_FILE_LOGIN;
const FileCommand FileCommand_MAX = RES_FILE_LOGIN;
const int FileCommand_ARRAYSIZE = FileCommand_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileCommand_descriptor();
inline const ::std::string& FileCommand_Name(FileCommand value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileCommand_descriptor(), value);
}
inline bool FileCommand_Parse(
    const ::std::string& name, FileCommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileCommand>(
    FileCommand_descriptor(), name, value);
}
enum SwitchCommand {
  P2P_CMD = 1537
};
bool SwitchCommand_IsValid(int value);
const SwitchCommand SwitchCommand_MIN = P2P_CMD;
const SwitchCommand SwitchCommand_MAX = P2P_CMD;
const int SwitchCommand_ARRAYSIZE = SwitchCommand_MAX + 1;

const ::google::protobuf::EnumDescriptor* SwitchCommand_descriptor();
inline const ::std::string& SwitchCommand_Name(SwitchCommand value) {
  return ::google::protobuf::internal::NameOfEnum(
    SwitchCommand_descriptor(), value);
}
inline bool SwitchCommand_Parse(
    const ::std::string& name, SwitchCommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SwitchCommand>(
    SwitchCommand_descriptor(), name, value);
}
enum OtherCommand {
  HEARTBEAT = 1793,
  STOP_RECV_PACKET = 1794,
  REQ_GET_DEVICE_TOKEN = 1797,
  RES_GET_DEVICE_TOKEN = 1798,
  ROLE_SET = 1799,
  ONLINE_USER_INFO = 1800,
  MSG_SERVER_INFO = 1801,
  USER_INFO_UPDATE = 1802,
  USER_COUNT_UPDATE = 1803,
  SERVER_KICK_USER = 1804,
  LOGIN_STATUS_NOTIFY = 1805,
  REQ_PUSH_TO_USER = 1806,
  RES_PUSH_TO_USER = 1807,
  REQ_GET_SHIELD = 1809,
  RES_GET_SHIELD = 1810,
  REQ_FILE_TRANSFER = 1811,
  RES_FILE_TRANSFER = 1812,
  REQ_FILE_SERVER_IP = 1813,
  RES_FILE_SERVER_IP = 1814
};
bool OtherCommand_IsValid(int value);
const OtherCommand OtherCommand_MIN = HEARTBEAT;
const OtherCommand OtherCommand_MAX = RES_FILE_SERVER_IP;
const int OtherCommand_ARRAYSIZE = OtherCommand_MAX + 1;

const ::google::protobuf::EnumDescriptor* OtherCommand_descriptor();
inline const ::std::string& OtherCommand_Name(OtherCommand value) {
  return ::google::protobuf::internal::NameOfEnum(
    OtherCommand_descriptor(), value);
}
inline bool OtherCommand_Parse(
    const ::std::string& name, OtherCommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OtherCommand>(
    OtherCommand_descriptor(), name, value);
}
enum SessionCmd {
  REQ_RECENT_SESSION = 2049,
  RES_RECENT_SESSION = 2050,
  REQ_REMOVE_SESSION = 2051,
  RES_REMOVE_SESSION = 2052
};
bool SessionCmd_IsValid(int value);
const SessionCmd SessionCmd_MIN = REQ_RECENT_SESSION;
const SessionCmd SessionCmd_MAX = RES_REMOVE_SESSION;
const int SessionCmd_ARRAYSIZE = SessionCmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* SessionCmd_descriptor();
inline const ::std::string& SessionCmd_Name(SessionCmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    SessionCmd_descriptor(), value);
}
inline bool SessionCmd_Parse(
    const ::std::string& name, SessionCmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SessionCmd>(
    SessionCmd_descriptor(), name, value);
}
enum UserCmd {
  REQ_USER_INFO = 2305,
  RES_USER_INFO = 2306,
  REQ_ALL_USER = 2307,
  RES_ALL_USER = 2308
};
bool UserCmd_IsValid(int value);
const UserCmd UserCmd_MIN = REQ_USER_INFO;
const UserCmd UserCmd_MAX = RES_ALL_USER;
const int UserCmd_ARRAYSIZE = UserCmd_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserCmd_descriptor();
inline const ::std::string& UserCmd_Name(UserCmd value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserCmd_descriptor(), value);
}
inline bool UserCmd_Parse(
    const ::std::string& name, UserCmd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserCmd>(
    UserCmd_descriptor(), name, value);
}
enum ResultType {
  REFUSE_REASON_NONE = 1,
  REFUSE_REASON_NO_SERVER = 2,
  REFUSE_REASON_MSG_SERVER_FULL = 3,
  REFUSE_REASON_NO_DB_SERVER = 4,
  REFUSE_REASON_NO_LOGIN_SERVER = 5,
  REFUSE_REASON_NO_ROUTE_SERVER = 6,
  REFUSE_REASON_DB_VALIDATE_FAILED = 7,
  REFUSE_REASON_VERSION_TOO_OLD = 8
};
bool ResultType_IsValid(int value);
const ResultType ResultType_MIN = REFUSE_REASON_NONE;
const ResultType ResultType_MAX = REFUSE_REASON_VERSION_TOO_OLD;
const int ResultType_ARRAYSIZE = ResultType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResultType_descriptor();
inline const ::std::string& ResultType_Name(ResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResultType_descriptor(), value);
}
inline bool ResultType_Parse(
    const ::std::string& name, ResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResultType>(
    ResultType_descriptor(), name, value);
}
enum KickReasonType {
  KICK_REASON_DUPLICATE_USER = 1,
  KICK_REASON_MOBILE_KICK = 2
};
bool KickReasonType_IsValid(int value);
const KickReasonType KickReasonType_MIN = KICK_REASON_DUPLICATE_USER;
const KickReasonType KickReasonType_MAX = KICK_REASON_MOBILE_KICK;
const int KickReasonType_ARRAYSIZE = KickReasonType_MAX + 1;

const ::google::protobuf::EnumDescriptor* KickReasonType_descriptor();
inline const ::std::string& KickReasonType_Name(KickReasonType value) {
  return ::google::protobuf::internal::NameOfEnum(
    KickReasonType_descriptor(), value);
}
inline bool KickReasonType_Parse(
    const ::std::string& name, KickReasonType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KickReasonType>(
    KickReasonType_descriptor(), name, value);
}
enum OnlineListType {
  ONLINE_LIST_TYPE_FRIEND_LIST = 1
};
bool OnlineListType_IsValid(int value);
const OnlineListType OnlineListType_MIN = ONLINE_LIST_TYPE_FRIEND_LIST;
const OnlineListType OnlineListType_MAX = ONLINE_LIST_TYPE_FRIEND_LIST;
const int OnlineListType_ARRAYSIZE = OnlineListType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OnlineListType_descriptor();
inline const ::std::string& OnlineListType_Name(OnlineListType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OnlineListType_descriptor(), value);
}
inline bool OnlineListType_Parse(
    const ::std::string& name, OnlineListType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OnlineListType>(
    OnlineListType_descriptor(), name, value);
}
enum UserStatusType {
  USER_STATUS_ONLINE = 1,
  USER_STATUS_OFFLINE = 2,
  USER_STATUS_LEAVE = 3
};
bool UserStatusType_IsValid(int value);
const UserStatusType UserStatusType_MIN = USER_STATUS_ONLINE;
const UserStatusType UserStatusType_MAX = USER_STATUS_LEAVE;
const int UserStatusType_ARRAYSIZE = UserStatusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserStatusType_descriptor();
inline const ::std::string& UserStatusType_Name(UserStatusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserStatusType_descriptor(), value);
}
inline bool UserStatusType_Parse(
    const ::std::string& name, UserStatusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserStatusType>(
    UserStatusType_descriptor(), name, value);
}
enum SessionType {
  SESSION_TYPE_SINGLE = 1,
  SESSION_TYPE_GROUP = 2
};
bool SessionType_IsValid(int value);
const SessionType SessionType_MIN = SESSION_TYPE_SINGLE;
const SessionType SessionType_MAX = SESSION_TYPE_GROUP;
const int SessionType_ARRAYSIZE = SessionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SessionType_descriptor();
inline const ::std::string& SessionType_Name(SessionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SessionType_descriptor(), value);
}
inline bool SessionType_Parse(
    const ::std::string& name, SessionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SessionType>(
    SessionType_descriptor(), name, value);
}
enum MsgType {
  MSG_TYPE_SINGLE_TEXT = 1,
  MSG_TYPE_SINGLE_AUDIO = 2,
  MSG_TYPE_GROUP_TEXT = 3,
  MSG_TYPE_GROUP_AUDIO = 4
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = MSG_TYPE_SINGLE_TEXT;
const MsgType MsgType_MAX = MSG_TYPE_GROUP_AUDIO;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum ClientType {
  CLIENT_TYPE_ANDROID = 1,
  CLIENT_TYPE_IOS = 2,
  CLIENT_TYPE_WINDOWS = 3,
  CLIENT_TYPE_MAC = 4,
  CLIENT_TYPE_LINUX = 5
};
bool ClientType_IsValid(int value);
const ClientType ClientType_MIN = CLIENT_TYPE_ANDROID;
const ClientType ClientType_MAX = CLIENT_TYPE_LINUX;
const int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientType_descriptor();
inline const ::std::string& ClientType_Name(ClientType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientType_descriptor(), value);
}
inline bool ClientType_Parse(
    const ::std::string& name, ClientType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientType>(
    ClientType_descriptor(), name, value);
}
enum GroupType {
  GROUP_TYPE_NORMAL = 1,
  GROUP_TYPE_TMP = 2
};
bool GroupType_IsValid(int value);
const GroupType GroupType_MIN = GROUP_TYPE_NORMAL;
const GroupType GroupType_MAX = GROUP_TYPE_TMP;
const int GroupType_ARRAYSIZE = GroupType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupType_descriptor();
inline const ::std::string& GroupType_Name(GroupType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupType_descriptor(), value);
}
inline bool GroupType_Parse(
    const ::std::string& name, GroupType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupType>(
    GroupType_descriptor(), name, value);
}
enum GroupModifyType {
  GROUP_MODIFY_TYPE_ADD = 1,
  GROUP_MODIFY_TYPE_DEL = 2
};
bool GroupModifyType_IsValid(int value);
const GroupModifyType GroupModifyType_MIN = GROUP_MODIFY_TYPE_ADD;
const GroupModifyType GroupModifyType_MAX = GROUP_MODIFY_TYPE_DEL;
const int GroupModifyType_ARRAYSIZE = GroupModifyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupModifyType_descriptor();
inline const ::std::string& GroupModifyType_Name(GroupModifyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupModifyType_descriptor(), value);
}
inline bool GroupModifyType_Parse(
    const ::std::string& name, GroupModifyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupModifyType>(
    GroupModifyType_descriptor(), name, value);
}
enum FileType {
  FILE_TYPE_ONLINE = 1,
  FILE_TYPE_OFFLINE = 2
};
bool FileType_IsValid(int value);
const FileType FileType_MIN = FILE_TYPE_ONLINE;
const FileType FileType_MAX = FILE_TYPE_OFFLINE;
const int FileType_ARRAYSIZE = FileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileType_descriptor();
inline const ::std::string& FileType_Name(FileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileType_descriptor(), value);
}
inline bool FileType_Parse(
    const ::std::string& name, FileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileType>(
    FileType_descriptor(), name, value);
}
enum ClientFileStatus {
  CLIENT_FILE_PEER_READY = 1,
  CLIENT_FILE_CANCEL = 2,
  CLIENT_FILE_REFUSE = 3,
  CLIENT_FILE_DONE = 4
};
bool ClientFileStatus_IsValid(int value);
const ClientFileStatus ClientFileStatus_MIN = CLIENT_FILE_PEER_READY;
const ClientFileStatus ClientFileStatus_MAX = CLIENT_FILE_DONE;
const int ClientFileStatus_ARRAYSIZE = ClientFileStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientFileStatus_descriptor();
inline const ::std::string& ClientFileStatus_Name(ClientFileStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientFileStatus_descriptor(), value);
}
inline bool ClientFileStatus_Parse(
    const ::std::string& name, ClientFileStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientFileStatus>(
    ClientFileStatus_descriptor(), name, value);
}
enum ClientFileRole {
  FILE_REALTIME_SENDER = 1,
  FILE_REALTIME_RECVER = 2,
  FILE_OFFLINE_UPLOAD = 3,
  FILE_OFFLINE_DOWNLOAD = 4
};
bool ClientFileRole_IsValid(int value);
const ClientFileRole ClientFileRole_MIN = FILE_REALTIME_SENDER;
const ClientFileRole ClientFileRole_MAX = FILE_OFFLINE_DOWNLOAD;
const int ClientFileRole_ARRAYSIZE = ClientFileRole_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientFileRole_descriptor();
inline const ::std::string& ClientFileRole_Name(ClientFileRole value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientFileRole_descriptor(), value);
}
inline bool ClientFileRole_Parse(
    const ::std::string& name, ClientFileRole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientFileRole>(
    ClientFileRole_descriptor(), name, value);
}
enum FileServerError {
  FILE_SERVER_OK = 1,
  FILE_SERVER_CREATE_TASK_ID_ERROR = 2,
  FILE_SERVER_CREATE_TASK_ERROR = 3,
  FILE_SERVER_LOGIN_INVALID_TOKEN_ERROR = 4,
  FILE_SERVER_INVALID_USER_FOR_TASK_ERROR = 5,
  FILE_SERVER_PULL_DATA_WITH_INVALID_TASK_ID_ERROR = 6,
  FILE_SERVER_PULL_DATA_ILLEGAL_USER_ERROR = 7,
  FILE_SERVER_PULL_DATA_MKDIR_ERROR = 8,
  FILE_SERVER_PULL_DATA_OPEN_FILE_ERROR = 9,
  FILE_SERVER_PULL_DATA_READ_FILE_HEADER_ERROR = 10,
  FILE_SERVER_PULL_DATA_ALLOC_MEM_ERROR = 11,
  FILE_SERVER_PULL_DATA_SEEK_OFFSET_ERROR = 12,
  FILE_SERVER_PULL_DATA_FINISHED_ERROR = 13
};
bool FileServerError_IsValid(int value);
const FileServerError FileServerError_MIN = FILE_SERVER_OK;
const FileServerError FileServerError_MAX = FILE_SERVER_PULL_DATA_FINISHED_ERROR;
const int FileServerError_ARRAYSIZE = FileServerError_MAX + 1;

const ::google::protobuf::EnumDescriptor* FileServerError_descriptor();
inline const ::std::string& FileServerError_Name(FileServerError value) {
  return ::google::protobuf::internal::NameOfEnum(
    FileServerError_descriptor(), value);
}
inline bool FileServerError_Parse(
    const ::std::string& name, FileServerError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FileServerError>(
    FileServerError_descriptor(), name, value);
}
enum SessionStatusType {
  SESSION_STATUS_OK = 1,
  SESSION_STATUS_DELETE = 2
};
bool SessionStatusType_IsValid(int value);
const SessionStatusType SessionStatusType_MIN = SESSION_STATUS_OK;
const SessionStatusType SessionStatusType_MAX = SESSION_STATUS_DELETE;
const int SessionStatusType_ARRAYSIZE = SessionStatusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SessionStatusType_descriptor();
inline const ::std::string& SessionStatusType_Name(SessionStatusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SessionStatusType_descriptor(), value);
}
inline bool SessionStatusType_Parse(
    const ::std::string& name, SessionStatusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SessionStatusType>(
    SessionStatusType_descriptor(), name, value);
}
// ===================================================================

class IpAddr : public ::google::protobuf::Message {
 public:
  IpAddr();
  virtual ~IpAddr();

  IpAddr(const IpAddr& from);

  inline IpAddr& operator=(const IpAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IpAddr& default_instance();

  void Swap(IpAddr* other);

  // implements Message ----------------------------------------------

  IpAddr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpAddr& from);
  void MergeFrom(const IpAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Base.IpAddr)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static IpAddr* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 sex = 2;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 2;
  inline ::google::protobuf::uint32 sex() const;
  inline void set_sex(::google::protobuf::uint32 value);

  // required string nick = 3;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 3;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required string avatar = 4;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 4;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // required string phone = 5;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 5;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // required string email = 6;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 6;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // required string name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string domain = 8;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 8;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // required uint32 status = 9;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 9;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Base.UserInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 sex_;
  ::std::string* nick_;
  ::std::string* avatar_;
  ::std::string* phone_;
  ::std::string* email_;
  ::std::string* name_;
  ::std::string* domain_;
  ::google::protobuf::uint32 status_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContactSessionInfo : public ::google::protobuf::Message {
 public:
  ContactSessionInfo();
  virtual ~ContactSessionInfo();

  ContactSessionInfo(const ContactSessionInfo& from);

  inline ContactSessionInfo& operator=(const ContactSessionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactSessionInfo& default_instance();

  void Swap(ContactSessionInfo* other);

  // implements Message ----------------------------------------------

  ContactSessionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContactSessionInfo& from);
  void MergeFrom(const ContactSessionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required .Im.Base.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::Im::Base::SessionType session_type() const;
  inline void set_session_type(::Im::Base::SessionType value);

  // required .Im.Base.SessionStatusType session_status = 3;
  inline bool has_session_status() const;
  inline void clear_session_status();
  static const int kSessionStatusFieldNumber = 3;
  inline ::Im::Base::SessionStatusType session_status() const;
  inline void set_session_status(::Im::Base::SessionStatusType value);

  // required uint32 update_time = 4;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 update_time() const;
  inline void set_update_time(::google::protobuf::uint32 value);

  // required uint32 latest_msg_id = 5;
  inline bool has_latest_msg_id() const;
  inline void clear_latest_msg_id();
  static const int kLatestMsgIdFieldNumber = 5;
  inline ::google::protobuf::uint32 latest_msg_id() const;
  inline void set_latest_msg_id(::google::protobuf::uint32 value);

  // required bytes latest_msg_data = 6;
  inline bool has_latest_msg_data() const;
  inline void clear_latest_msg_data();
  static const int kLatestMsgDataFieldNumber = 6;
  inline const ::std::string& latest_msg_data() const;
  inline void set_latest_msg_data(const ::std::string& value);
  inline void set_latest_msg_data(const char* value);
  inline void set_latest_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_latest_msg_data();
  inline ::std::string* release_latest_msg_data();
  inline void set_allocated_latest_msg_data(::std::string* latest_msg_data);

  // required .Im.Base.MsgType latest_msg_type = 7;
  inline bool has_latest_msg_type() const;
  inline void clear_latest_msg_type();
  static const int kLatestMsgTypeFieldNumber = 7;
  inline ::Im::Base::MsgType latest_msg_type() const;
  inline void set_latest_msg_type(::Im::Base::MsgType value);

  // required uint32 latest_msg_from_user_id = 8;
  inline bool has_latest_msg_from_user_id() const;
  inline void clear_latest_msg_from_user_id();
  static const int kLatestMsgFromUserIdFieldNumber = 8;
  inline ::google::protobuf::uint32 latest_msg_from_user_id() const;
  inline void set_latest_msg_from_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Base.ContactSessionInfo)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_status();
  inline void clear_has_session_status();
  inline void set_has_update_time();
  inline void clear_has_update_time();
  inline void set_has_latest_msg_id();
  inline void clear_has_latest_msg_id();
  inline void set_has_latest_msg_data();
  inline void clear_has_latest_msg_data();
  inline void set_has_latest_msg_type();
  inline void clear_has_latest_msg_type();
  inline void set_has_latest_msg_from_user_id();
  inline void clear_has_latest_msg_from_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_id_;
  int session_type_;
  int session_status_;
  ::google::protobuf::uint32 update_time_;
  ::std::string* latest_msg_data_;
  ::google::protobuf::uint32 latest_msg_id_;
  int latest_msg_type_;
  ::google::protobuf::uint32 latest_msg_from_user_id_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static ContactSessionInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserStatus : public ::google::protobuf::Message {
 public:
  UserStatus();
  virtual ~UserStatus();

  UserStatus(const UserStatus& from);

  inline UserStatus& operator=(const UserStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserStatus& default_instance();

  void Swap(UserStatus* other);

  // implements Message ----------------------------------------------

  UserStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserStatus& from);
  void MergeFrom(const UserStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .Im.Base.UserStatusType user_status = 2;
  inline bool has_user_status() const;
  inline void clear_user_status();
  static const int kUserStatusFieldNumber = 2;
  inline ::Im::Base::UserStatusType user_status() const;
  inline void set_user_status(::Im::Base::UserStatusType value);

  // @@protoc_insertion_point(class_scope:Im.Base.UserStatus)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_status();
  inline void clear_has_user_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int user_status_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static UserStatus* default_instance_;
};
// -------------------------------------------------------------------

class ServerUserStatus : public ::google::protobuf::Message {
 public:
  ServerUserStatus();
  virtual ~ServerUserStatus();

  ServerUserStatus(const ServerUserStatus& from);

  inline ServerUserStatus& operator=(const ServerUserStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerUserStatus& default_instance();

  void Swap(ServerUserStatus* other);

  // implements Message ----------------------------------------------

  ServerUserStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerUserStatus& from);
  void MergeFrom(const ServerUserStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .Im.Base.UserStatusType user_status = 2;
  inline bool has_user_status() const;
  inline void clear_user_status();
  static const int kUserStatusFieldNumber = 2;
  inline ::Im::Base::UserStatusType user_status() const;
  inline void set_user_status(::Im::Base::UserStatusType value);

  // required .Im.Base.ClientType client_type = 3;
  inline bool has_client_type() const;
  inline void clear_client_type();
  static const int kClientTypeFieldNumber = 3;
  inline ::Im::Base::ClientType client_type() const;
  inline void set_client_type(::Im::Base::ClientType value);

  // @@protoc_insertion_point(class_scope:Im.Base.ServerUserStatus)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_status();
  inline void clear_has_user_status();
  inline void set_has_client_type();
  inline void clear_has_client_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int user_status_;
  int client_type_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static ServerUserStatus* default_instance_;
};
// -------------------------------------------------------------------

class UnreadInfo : public ::google::protobuf::Message {
 public:
  UnreadInfo();
  virtual ~UnreadInfo();

  UnreadInfo(const UnreadInfo& from);

  inline UnreadInfo& operator=(const UnreadInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnreadInfo& default_instance();

  void Swap(UnreadInfo* other);

  // implements Message ----------------------------------------------

  UnreadInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnreadInfo& from);
  void MergeFrom(const UnreadInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required .Im.Base.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::Im::Base::SessionType session_type() const;
  inline void set_session_type(::Im::Base::SessionType value);

  // required uint32 unread_count = 3;
  inline bool has_unread_count() const;
  inline void clear_unread_count();
  static const int kUnreadCountFieldNumber = 3;
  inline ::google::protobuf::uint32 unread_count() const;
  inline void set_unread_count(::google::protobuf::uint32 value);

  // required uint32 latest_msg_id = 4;
  inline bool has_latest_msg_id() const;
  inline void clear_latest_msg_id();
  static const int kLatestMsgIdFieldNumber = 4;
  inline ::google::protobuf::uint32 latest_msg_id() const;
  inline void set_latest_msg_id(::google::protobuf::uint32 value);

  // required bytes latest_msg_data = 5;
  inline bool has_latest_msg_data() const;
  inline void clear_latest_msg_data();
  static const int kLatestMsgDataFieldNumber = 5;
  inline const ::std::string& latest_msg_data() const;
  inline void set_latest_msg_data(const ::std::string& value);
  inline void set_latest_msg_data(const char* value);
  inline void set_latest_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_latest_msg_data();
  inline ::std::string* release_latest_msg_data();
  inline void set_allocated_latest_msg_data(::std::string* latest_msg_data);

  // required .Im.Base.MsgType latest_msg_type = 6;
  inline bool has_latest_msg_type() const;
  inline void clear_latest_msg_type();
  static const int kLatestMsgTypeFieldNumber = 6;
  inline ::Im::Base::MsgType latest_msg_type() const;
  inline void set_latest_msg_type(::Im::Base::MsgType value);

  // required uint32 latest_msg_from_user_id = 7;
  inline bool has_latest_msg_from_user_id() const;
  inline void clear_latest_msg_from_user_id();
  static const int kLatestMsgFromUserIdFieldNumber = 7;
  inline ::google::protobuf::uint32 latest_msg_from_user_id() const;
  inline void set_latest_msg_from_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Base.UnreadInfo)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_unread_count();
  inline void clear_has_unread_count();
  inline void set_has_latest_msg_id();
  inline void clear_has_latest_msg_id();
  inline void set_has_latest_msg_data();
  inline void clear_has_latest_msg_data();
  inline void set_has_latest_msg_type();
  inline void clear_has_latest_msg_type();
  inline void set_has_latest_msg_from_user_id();
  inline void clear_has_latest_msg_from_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_id_;
  int session_type_;
  ::google::protobuf::uint32 unread_count_;
  ::google::protobuf::uint32 latest_msg_id_;
  ::std::string* latest_msg_data_;
  int latest_msg_type_;
  ::google::protobuf::uint32 latest_msg_from_user_id_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static UnreadInfo* default_instance_;
};
// -------------------------------------------------------------------

class MsgInfo : public ::google::protobuf::Message {
 public:
  MsgInfo();
  virtual ~MsgInfo();

  MsgInfo(const MsgInfo& from);

  inline MsgInfo& operator=(const MsgInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgInfo& default_instance();

  void Swap(MsgInfo* other);

  // implements Message ----------------------------------------------

  MsgInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgInfo& from);
  void MergeFrom(const MsgInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // required uint32 from_session_id = 2;
  inline bool has_from_session_id() const;
  inline void clear_from_session_id();
  static const int kFromSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_session_id() const;
  inline void set_from_session_id(::google::protobuf::uint32 value);

  // required uint32 create_time = 3;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // required .Im.Base.MsgType msg_type = 4;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 4;
  inline ::Im::Base::MsgType msg_type() const;
  inline void set_msg_type(::Im::Base::MsgType value);

  // required bytes msg_data = 5;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 5;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // @@protoc_insertion_point(class_scope:Im.Base.MsgInfo)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_from_session_id();
  inline void clear_has_from_session_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 msg_id_;
  ::google::protobuf::uint32 from_session_id_;
  ::google::protobuf::uint32 create_time_;
  int msg_type_;
  ::std::string* msg_data_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static MsgInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupVersionInfo : public ::google::protobuf::Message {
 public:
  GroupVersionInfo();
  virtual ~GroupVersionInfo();

  GroupVersionInfo(const GroupVersionInfo& from);

  inline GroupVersionInfo& operator=(const GroupVersionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupVersionInfo& default_instance();

  void Swap(GroupVersionInfo* other);

  // implements Message ----------------------------------------------

  GroupVersionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupVersionInfo& from);
  void MergeFrom(const GroupVersionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Base.GroupVersionInfo)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static GroupVersionInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupInfo : public ::google::protobuf::Message {
 public:
  GroupInfo();
  virtual ~GroupInfo();

  GroupInfo(const GroupInfo& from);

  inline GroupInfo& operator=(const GroupInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupInfo& default_instance();

  void Swap(GroupInfo* other);

  // implements Message ----------------------------------------------

  GroupInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupInfo& from);
  void MergeFrom(const GroupInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required uint32 from_user_id = 3;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 3;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);

  // required string group_name = 4;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 4;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // required string group_avatar = 5;
  inline bool has_group_avatar() const;
  inline void clear_group_avatar();
  static const int kGroupAvatarFieldNumber = 5;
  inline const ::std::string& group_avatar() const;
  inline void set_group_avatar(const ::std::string& value);
  inline void set_group_avatar(const char* value);
  inline void set_group_avatar(const char* value, size_t size);
  inline ::std::string* mutable_group_avatar();
  inline ::std::string* release_group_avatar();
  inline void set_allocated_group_avatar(::std::string* group_avatar);

  // required .Im.Base.GroupType group_type = 6;
  inline bool has_group_type() const;
  inline void clear_group_type();
  static const int kGroupTypeFieldNumber = 6;
  inline ::Im::Base::GroupType group_type() const;
  inline void set_group_type(::Im::Base::GroupType value);

  // required uint32 shield_status = 7;
  inline bool has_shield_status() const;
  inline void clear_shield_status();
  static const int kShieldStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 shield_status() const;
  inline void set_shield_status(::google::protobuf::uint32 value);

  // repeated uint32 group_member_list = 8;
  inline int group_member_list_size() const;
  inline void clear_group_member_list();
  static const int kGroupMemberListFieldNumber = 8;
  inline ::google::protobuf::uint32 group_member_list(int index) const;
  inline void set_group_member_list(int index, ::google::protobuf::uint32 value);
  inline void add_group_member_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      group_member_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_group_member_list();

  // @@protoc_insertion_point(class_scope:Im.Base.GroupInfo)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_group_avatar();
  inline void clear_has_group_avatar();
  inline void set_has_group_type();
  inline void clear_has_group_type();
  inline void set_has_shield_status();
  inline void clear_has_shield_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 version_;
  ::std::string* group_name_;
  ::google::protobuf::uint32 from_user_id_;
  int group_type_;
  ::std::string* group_avatar_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > group_member_list_;
  ::google::protobuf::uint32 shield_status_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static GroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserTokenInfo : public ::google::protobuf::Message {
 public:
  UserTokenInfo();
  virtual ~UserTokenInfo();

  UserTokenInfo(const UserTokenInfo& from);

  inline UserTokenInfo& operator=(const UserTokenInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTokenInfo& default_instance();

  void Swap(UserTokenInfo* other);

  // implements Message ----------------------------------------------

  UserTokenInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserTokenInfo& from);
  void MergeFrom(const UserTokenInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .Im.Base.ClientType client_type = 2;
  inline bool has_client_type() const;
  inline void clear_client_type();
  static const int kClientTypeFieldNumber = 2;
  inline ::Im::Base::ClientType client_type() const;
  inline void set_client_type(::Im::Base::ClientType value);

  // required string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required uint32 push_count = 4;
  inline bool has_push_count() const;
  inline void clear_push_count();
  static const int kPushCountFieldNumber = 4;
  inline ::google::protobuf::uint32 push_count() const;
  inline void set_push_count(::google::protobuf::uint32 value);

  // required uint32 push_type = 5;
  inline bool has_push_type() const;
  inline void clear_push_type();
  static const int kPushTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 push_type() const;
  inline void set_push_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Base.UserTokenInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_client_type();
  inline void clear_has_client_type();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_push_count();
  inline void clear_has_push_count();
  inline void set_has_push_type();
  inline void clear_has_push_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int client_type_;
  ::std::string* token_;
  ::google::protobuf::uint32 push_count_;
  ::google::protobuf::uint32 push_type_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static UserTokenInfo* default_instance_;
};
// -------------------------------------------------------------------

class PushResult : public ::google::protobuf::Message {
 public:
  PushResult();
  virtual ~PushResult();

  PushResult(const PushResult& from);

  inline PushResult& operator=(const PushResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PushResult& default_instance();

  void Swap(PushResult* other);

  // implements Message ----------------------------------------------

  PushResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PushResult& from);
  void MergeFrom(const PushResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_token = 1;
  inline bool has_user_token() const;
  inline void clear_user_token();
  static const int kUserTokenFieldNumber = 1;
  inline const ::std::string& user_token() const;
  inline void set_user_token(const ::std::string& value);
  inline void set_user_token(const char* value);
  inline void set_user_token(const char* value, size_t size);
  inline ::std::string* mutable_user_token();
  inline ::std::string* release_user_token();
  inline void set_allocated_user_token(::std::string* user_token);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Base.PushResult)
 private:
  inline void set_has_user_token();
  inline void clear_has_user_token();
  inline void set_has_result_code();
  inline void clear_has_result_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_token_;
  ::google::protobuf::uint32 result_code_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static PushResult* default_instance_;
};
// -------------------------------------------------------------------

class ShieldStatus : public ::google::protobuf::Message {
 public:
  ShieldStatus();
  virtual ~ShieldStatus();

  ShieldStatus(const ShieldStatus& from);

  inline ShieldStatus& operator=(const ShieldStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShieldStatus& default_instance();

  void Swap(ShieldStatus* other);

  // implements Message ----------------------------------------------

  ShieldStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShieldStatus& from);
  void MergeFrom(const ShieldStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 shield_status = 3;
  inline bool has_shield_status() const;
  inline void clear_shield_status();
  static const int kShieldStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 shield_status() const;
  inline void set_shield_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Base.ShieldStatus)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_shield_status();
  inline void clear_has_shield_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 shield_status_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static ShieldStatus* default_instance_;
};
// -------------------------------------------------------------------

class OfflineFileInfo : public ::google::protobuf::Message {
 public:
  OfflineFileInfo();
  virtual ~OfflineFileInfo();

  OfflineFileInfo(const OfflineFileInfo& from);

  inline OfflineFileInfo& operator=(const OfflineFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OfflineFileInfo& default_instance();

  void Swap(OfflineFileInfo* other);

  // implements Message ----------------------------------------------

  OfflineFileInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OfflineFileInfo& from);
  void MergeFrom(const OfflineFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from_user_id = 1;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);

  // required string task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  inline void set_allocated_task_id(::std::string* task_id);

  // required string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // required string file_size = 4;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  inline const ::std::string& file_size() const;
  inline void set_file_size(const ::std::string& value);
  inline void set_file_size(const char* value);
  inline void set_file_size(const char* value, size_t size);
  inline ::std::string* mutable_file_size();
  inline ::std::string* release_file_size();
  inline void set_allocated_file_size(::std::string* file_size);

  // @@protoc_insertion_point(class_scope:Im.Base.OfflineFileInfo)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* task_id_;
  ::std::string* file_name_;
  ::std::string* file_size_;
  ::google::protobuf::uint32 from_user_id_;
  friend void  protobuf_AddDesc_Im_2eBase_2eproto();
  friend void protobuf_AssignDesc_Im_2eBase_2eproto();
  friend void protobuf_ShutdownFile_Im_2eBase_2eproto();

  void InitAsDefaultInstance();
  static OfflineFileInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// IpAddr

// required string id = 1;
inline bool IpAddr::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpAddr::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpAddr::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpAddr::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& IpAddr::id() const {
  // @@protoc_insertion_point(field_get:Im.Base.IpAddr.id)
  return *id_;
}
inline void IpAddr::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.IpAddr.id)
}
inline void IpAddr::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.IpAddr.id)
}
inline void IpAddr::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.IpAddr.id)
}
inline ::std::string* IpAddr::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.IpAddr.id)
  return id_;
}
inline ::std::string* IpAddr::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IpAddr::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.IpAddr.id)
}

// required uint32 port = 2;
inline bool IpAddr::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpAddr::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 IpAddr::port() const {
  // @@protoc_insertion_point(field_get:Im.Base.IpAddr.port)
  return port_;
}
inline void IpAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.IpAddr.port)
}

// -------------------------------------------------------------------

// UserInfo

// required uint32 user_id = 1;
inline bool UserInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserInfo.user_id)
  return user_id_;
}
inline void UserInfo::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UserInfo.user_id)
}

// required uint32 sex = 2;
inline bool UserInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_sex() {
  sex_ = 0u;
  clear_has_sex();
}
inline ::google::protobuf::uint32 UserInfo::sex() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserInfo.sex)
  return sex_;
}
inline void UserInfo::set_sex(::google::protobuf::uint32 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UserInfo.sex)
}

// required string nick = 3;
inline bool UserInfo::has_nick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_nick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_nick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_nick() {
  if (nick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& UserInfo::nick() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserInfo.nick)
  return *nick_;
}
inline void UserInfo::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.UserInfo.nick)
}
inline void UserInfo::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.UserInfo.nick)
}
inline void UserInfo::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.UserInfo.nick)
}
inline ::std::string* UserInfo::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nick_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.UserInfo.nick)
  return nick_;
}
inline ::std::string* UserInfo::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.UserInfo.nick)
}

// required string avatar = 4;
inline bool UserInfo::has_avatar() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_avatar() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& UserInfo::avatar() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserInfo.avatar)
  return *avatar_;
}
inline void UserInfo::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.UserInfo.avatar)
}
inline void UserInfo::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.UserInfo.avatar)
}
inline void UserInfo::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.UserInfo.avatar)
}
inline ::std::string* UserInfo::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    avatar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.UserInfo.avatar)
  return avatar_;
}
inline ::std::string* UserInfo::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.UserInfo.avatar)
}

// required string phone = 5;
inline bool UserInfo::has_phone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_phone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_phone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_phone() {
  if (phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& UserInfo::phone() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserInfo.phone)
  return *phone_;
}
inline void UserInfo::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.UserInfo.phone)
}
inline void UserInfo::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.UserInfo.phone)
}
inline void UserInfo::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.UserInfo.phone)
}
inline ::std::string* UserInfo::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.UserInfo.phone)
  return phone_;
}
inline ::std::string* UserInfo::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.UserInfo.phone)
}

// required string email = 6;
inline bool UserInfo::has_email() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_email() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_email() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& UserInfo::email() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserInfo.email)
  return *email_;
}
inline void UserInfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.UserInfo.email)
}
inline void UserInfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.UserInfo.email)
}
inline void UserInfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.UserInfo.email)
}
inline ::std::string* UserInfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.UserInfo.email)
  return email_;
}
inline ::std::string* UserInfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.UserInfo.email)
}

// required string name = 7;
inline bool UserInfo::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserInfo::name() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserInfo.name)
  return *name_;
}
inline void UserInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.UserInfo.name)
}
inline void UserInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.UserInfo.name)
}
inline void UserInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.UserInfo.name)
}
inline ::std::string* UserInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.UserInfo.name)
  return name_;
}
inline ::std::string* UserInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.UserInfo.name)
}

// required string domain = 8;
inline bool UserInfo::has_domain() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_domain() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_domain() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_domain() {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& UserInfo::domain() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserInfo.domain)
  return *domain_;
}
inline void UserInfo::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.UserInfo.domain)
}
inline void UserInfo::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.UserInfo.domain)
}
inline void UserInfo::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.UserInfo.domain)
}
inline ::std::string* UserInfo::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.UserInfo.domain)
  return domain_;
}
inline ::std::string* UserInfo::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.UserInfo.domain)
}

// required uint32 status = 9;
inline bool UserInfo::has_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 UserInfo::status() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserInfo.status)
  return status_;
}
inline void UserInfo::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UserInfo.status)
}

// -------------------------------------------------------------------

// ContactSessionInfo

// required uint32 session_id = 1;
inline bool ContactSessionInfo::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactSessionInfo::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactSessionInfo::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactSessionInfo::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 ContactSessionInfo::session_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.ContactSessionInfo.session_id)
  return session_id_;
}
inline void ContactSessionInfo::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ContactSessionInfo.session_id)
}

// required .Im.Base.SessionType session_type = 2;
inline bool ContactSessionInfo::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactSessionInfo::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactSessionInfo::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactSessionInfo::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::Im::Base::SessionType ContactSessionInfo::session_type() const {
  // @@protoc_insertion_point(field_get:Im.Base.ContactSessionInfo.session_type)
  return static_cast< ::Im::Base::SessionType >(session_type_);
}
inline void ContactSessionInfo::set_session_type(::Im::Base::SessionType value) {
  assert(::Im::Base::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ContactSessionInfo.session_type)
}

// required .Im.Base.SessionStatusType session_status = 3;
inline bool ContactSessionInfo::has_session_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContactSessionInfo::set_has_session_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContactSessionInfo::clear_has_session_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContactSessionInfo::clear_session_status() {
  session_status_ = 1;
  clear_has_session_status();
}
inline ::Im::Base::SessionStatusType ContactSessionInfo::session_status() const {
  // @@protoc_insertion_point(field_get:Im.Base.ContactSessionInfo.session_status)
  return static_cast< ::Im::Base::SessionStatusType >(session_status_);
}
inline void ContactSessionInfo::set_session_status(::Im::Base::SessionStatusType value) {
  assert(::Im::Base::SessionStatusType_IsValid(value));
  set_has_session_status();
  session_status_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ContactSessionInfo.session_status)
}

// required uint32 update_time = 4;
inline bool ContactSessionInfo::has_update_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContactSessionInfo::set_has_update_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContactSessionInfo::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContactSessionInfo::clear_update_time() {
  update_time_ = 0u;
  clear_has_update_time();
}
inline ::google::protobuf::uint32 ContactSessionInfo::update_time() const {
  // @@protoc_insertion_point(field_get:Im.Base.ContactSessionInfo.update_time)
  return update_time_;
}
inline void ContactSessionInfo::set_update_time(::google::protobuf::uint32 value) {
  set_has_update_time();
  update_time_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ContactSessionInfo.update_time)
}

// required uint32 latest_msg_id = 5;
inline bool ContactSessionInfo::has_latest_msg_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContactSessionInfo::set_has_latest_msg_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContactSessionInfo::clear_has_latest_msg_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContactSessionInfo::clear_latest_msg_id() {
  latest_msg_id_ = 0u;
  clear_has_latest_msg_id();
}
inline ::google::protobuf::uint32 ContactSessionInfo::latest_msg_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.ContactSessionInfo.latest_msg_id)
  return latest_msg_id_;
}
inline void ContactSessionInfo::set_latest_msg_id(::google::protobuf::uint32 value) {
  set_has_latest_msg_id();
  latest_msg_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ContactSessionInfo.latest_msg_id)
}

// required bytes latest_msg_data = 6;
inline bool ContactSessionInfo::has_latest_msg_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContactSessionInfo::set_has_latest_msg_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContactSessionInfo::clear_has_latest_msg_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContactSessionInfo::clear_latest_msg_data() {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_->clear();
  }
  clear_has_latest_msg_data();
}
inline const ::std::string& ContactSessionInfo::latest_msg_data() const {
  // @@protoc_insertion_point(field_get:Im.Base.ContactSessionInfo.latest_msg_data)
  return *latest_msg_data_;
}
inline void ContactSessionInfo::set_latest_msg_data(const ::std::string& value) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.ContactSessionInfo.latest_msg_data)
}
inline void ContactSessionInfo::set_latest_msg_data(const char* value) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.ContactSessionInfo.latest_msg_data)
}
inline void ContactSessionInfo::set_latest_msg_data(const void* value, size_t size) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.ContactSessionInfo.latest_msg_data)
}
inline ::std::string* ContactSessionInfo::mutable_latest_msg_data() {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.ContactSessionInfo.latest_msg_data)
  return latest_msg_data_;
}
inline ::std::string* ContactSessionInfo::release_latest_msg_data() {
  clear_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = latest_msg_data_;
    latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContactSessionInfo::set_allocated_latest_msg_data(::std::string* latest_msg_data) {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete latest_msg_data_;
  }
  if (latest_msg_data) {
    set_has_latest_msg_data();
    latest_msg_data_ = latest_msg_data;
  } else {
    clear_has_latest_msg_data();
    latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.ContactSessionInfo.latest_msg_data)
}

// required .Im.Base.MsgType latest_msg_type = 7;
inline bool ContactSessionInfo::has_latest_msg_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContactSessionInfo::set_has_latest_msg_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContactSessionInfo::clear_has_latest_msg_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContactSessionInfo::clear_latest_msg_type() {
  latest_msg_type_ = 1;
  clear_has_latest_msg_type();
}
inline ::Im::Base::MsgType ContactSessionInfo::latest_msg_type() const {
  // @@protoc_insertion_point(field_get:Im.Base.ContactSessionInfo.latest_msg_type)
  return static_cast< ::Im::Base::MsgType >(latest_msg_type_);
}
inline void ContactSessionInfo::set_latest_msg_type(::Im::Base::MsgType value) {
  assert(::Im::Base::MsgType_IsValid(value));
  set_has_latest_msg_type();
  latest_msg_type_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ContactSessionInfo.latest_msg_type)
}

// required uint32 latest_msg_from_user_id = 8;
inline bool ContactSessionInfo::has_latest_msg_from_user_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContactSessionInfo::set_has_latest_msg_from_user_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContactSessionInfo::clear_has_latest_msg_from_user_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ContactSessionInfo::clear_latest_msg_from_user_id() {
  latest_msg_from_user_id_ = 0u;
  clear_has_latest_msg_from_user_id();
}
inline ::google::protobuf::uint32 ContactSessionInfo::latest_msg_from_user_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.ContactSessionInfo.latest_msg_from_user_id)
  return latest_msg_from_user_id_;
}
inline void ContactSessionInfo::set_latest_msg_from_user_id(::google::protobuf::uint32 value) {
  set_has_latest_msg_from_user_id();
  latest_msg_from_user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ContactSessionInfo.latest_msg_from_user_id)
}

// -------------------------------------------------------------------

// UserStatus

// required uint32 user_id = 1;
inline bool UserStatus::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStatus::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStatus::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStatus::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserStatus::user_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserStatus.user_id)
  return user_id_;
}
inline void UserStatus::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UserStatus.user_id)
}

// required .Im.Base.UserStatusType user_status = 2;
inline bool UserStatus::has_user_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStatus::set_has_user_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStatus::clear_has_user_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStatus::clear_user_status() {
  user_status_ = 1;
  clear_has_user_status();
}
inline ::Im::Base::UserStatusType UserStatus::user_status() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserStatus.user_status)
  return static_cast< ::Im::Base::UserStatusType >(user_status_);
}
inline void UserStatus::set_user_status(::Im::Base::UserStatusType value) {
  assert(::Im::Base::UserStatusType_IsValid(value));
  set_has_user_status();
  user_status_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UserStatus.user_status)
}

// -------------------------------------------------------------------

// ServerUserStatus

// required uint32 user_id = 1;
inline bool ServerUserStatus::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerUserStatus::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerUserStatus::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerUserStatus::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 ServerUserStatus::user_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.ServerUserStatus.user_id)
  return user_id_;
}
inline void ServerUserStatus::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ServerUserStatus.user_id)
}

// required .Im.Base.UserStatusType user_status = 2;
inline bool ServerUserStatus::has_user_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerUserStatus::set_has_user_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerUserStatus::clear_has_user_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerUserStatus::clear_user_status() {
  user_status_ = 1;
  clear_has_user_status();
}
inline ::Im::Base::UserStatusType ServerUserStatus::user_status() const {
  // @@protoc_insertion_point(field_get:Im.Base.ServerUserStatus.user_status)
  return static_cast< ::Im::Base::UserStatusType >(user_status_);
}
inline void ServerUserStatus::set_user_status(::Im::Base::UserStatusType value) {
  assert(::Im::Base::UserStatusType_IsValid(value));
  set_has_user_status();
  user_status_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ServerUserStatus.user_status)
}

// required .Im.Base.ClientType client_type = 3;
inline bool ServerUserStatus::has_client_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerUserStatus::set_has_client_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerUserStatus::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerUserStatus::clear_client_type() {
  client_type_ = 1;
  clear_has_client_type();
}
inline ::Im::Base::ClientType ServerUserStatus::client_type() const {
  // @@protoc_insertion_point(field_get:Im.Base.ServerUserStatus.client_type)
  return static_cast< ::Im::Base::ClientType >(client_type_);
}
inline void ServerUserStatus::set_client_type(::Im::Base::ClientType value) {
  assert(::Im::Base::ClientType_IsValid(value));
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ServerUserStatus.client_type)
}

// -------------------------------------------------------------------

// UnreadInfo

// required uint32 session_id = 1;
inline bool UnreadInfo::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnreadInfo::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnreadInfo::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnreadInfo::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 UnreadInfo::session_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.UnreadInfo.session_id)
  return session_id_;
}
inline void UnreadInfo::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UnreadInfo.session_id)
}

// required .Im.Base.SessionType session_type = 2;
inline bool UnreadInfo::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnreadInfo::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnreadInfo::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnreadInfo::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::Im::Base::SessionType UnreadInfo::session_type() const {
  // @@protoc_insertion_point(field_get:Im.Base.UnreadInfo.session_type)
  return static_cast< ::Im::Base::SessionType >(session_type_);
}
inline void UnreadInfo::set_session_type(::Im::Base::SessionType value) {
  assert(::Im::Base::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UnreadInfo.session_type)
}

// required uint32 unread_count = 3;
inline bool UnreadInfo::has_unread_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnreadInfo::set_has_unread_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnreadInfo::clear_has_unread_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnreadInfo::clear_unread_count() {
  unread_count_ = 0u;
  clear_has_unread_count();
}
inline ::google::protobuf::uint32 UnreadInfo::unread_count() const {
  // @@protoc_insertion_point(field_get:Im.Base.UnreadInfo.unread_count)
  return unread_count_;
}
inline void UnreadInfo::set_unread_count(::google::protobuf::uint32 value) {
  set_has_unread_count();
  unread_count_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UnreadInfo.unread_count)
}

// required uint32 latest_msg_id = 4;
inline bool UnreadInfo::has_latest_msg_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnreadInfo::clear_has_latest_msg_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnreadInfo::clear_latest_msg_id() {
  latest_msg_id_ = 0u;
  clear_has_latest_msg_id();
}
inline ::google::protobuf::uint32 UnreadInfo::latest_msg_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.UnreadInfo.latest_msg_id)
  return latest_msg_id_;
}
inline void UnreadInfo::set_latest_msg_id(::google::protobuf::uint32 value) {
  set_has_latest_msg_id();
  latest_msg_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UnreadInfo.latest_msg_id)
}

// required bytes latest_msg_data = 5;
inline bool UnreadInfo::has_latest_msg_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UnreadInfo::clear_has_latest_msg_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UnreadInfo::clear_latest_msg_data() {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_->clear();
  }
  clear_has_latest_msg_data();
}
inline const ::std::string& UnreadInfo::latest_msg_data() const {
  // @@protoc_insertion_point(field_get:Im.Base.UnreadInfo.latest_msg_data)
  return *latest_msg_data_;
}
inline void UnreadInfo::set_latest_msg_data(const ::std::string& value) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.UnreadInfo.latest_msg_data)
}
inline void UnreadInfo::set_latest_msg_data(const char* value) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.UnreadInfo.latest_msg_data)
}
inline void UnreadInfo::set_latest_msg_data(const void* value, size_t size) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.UnreadInfo.latest_msg_data)
}
inline ::std::string* UnreadInfo::mutable_latest_msg_data() {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.UnreadInfo.latest_msg_data)
  return latest_msg_data_;
}
inline ::std::string* UnreadInfo::release_latest_msg_data() {
  clear_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = latest_msg_data_;
    latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UnreadInfo::set_allocated_latest_msg_data(::std::string* latest_msg_data) {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete latest_msg_data_;
  }
  if (latest_msg_data) {
    set_has_latest_msg_data();
    latest_msg_data_ = latest_msg_data;
  } else {
    clear_has_latest_msg_data();
    latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.UnreadInfo.latest_msg_data)
}

// required .Im.Base.MsgType latest_msg_type = 6;
inline bool UnreadInfo::has_latest_msg_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UnreadInfo::clear_has_latest_msg_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UnreadInfo::clear_latest_msg_type() {
  latest_msg_type_ = 1;
  clear_has_latest_msg_type();
}
inline ::Im::Base::MsgType UnreadInfo::latest_msg_type() const {
  // @@protoc_insertion_point(field_get:Im.Base.UnreadInfo.latest_msg_type)
  return static_cast< ::Im::Base::MsgType >(latest_msg_type_);
}
inline void UnreadInfo::set_latest_msg_type(::Im::Base::MsgType value) {
  assert(::Im::Base::MsgType_IsValid(value));
  set_has_latest_msg_type();
  latest_msg_type_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UnreadInfo.latest_msg_type)
}

// required uint32 latest_msg_from_user_id = 7;
inline bool UnreadInfo::has_latest_msg_from_user_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_from_user_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UnreadInfo::clear_has_latest_msg_from_user_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UnreadInfo::clear_latest_msg_from_user_id() {
  latest_msg_from_user_id_ = 0u;
  clear_has_latest_msg_from_user_id();
}
inline ::google::protobuf::uint32 UnreadInfo::latest_msg_from_user_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.UnreadInfo.latest_msg_from_user_id)
  return latest_msg_from_user_id_;
}
inline void UnreadInfo::set_latest_msg_from_user_id(::google::protobuf::uint32 value) {
  set_has_latest_msg_from_user_id();
  latest_msg_from_user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UnreadInfo.latest_msg_from_user_id)
}

// -------------------------------------------------------------------

// MsgInfo

// required uint32 msg_id = 1;
inline bool MsgInfo::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgInfo::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgInfo::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgInfo::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 MsgInfo::msg_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.MsgInfo.msg_id)
  return msg_id_;
}
inline void MsgInfo::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.MsgInfo.msg_id)
}

// required uint32 from_session_id = 2;
inline bool MsgInfo::has_from_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgInfo::set_has_from_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgInfo::clear_has_from_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgInfo::clear_from_session_id() {
  from_session_id_ = 0u;
  clear_has_from_session_id();
}
inline ::google::protobuf::uint32 MsgInfo::from_session_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.MsgInfo.from_session_id)
  return from_session_id_;
}
inline void MsgInfo::set_from_session_id(::google::protobuf::uint32 value) {
  set_has_from_session_id();
  from_session_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.MsgInfo.from_session_id)
}

// required uint32 create_time = 3;
inline bool MsgInfo::has_create_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgInfo::set_has_create_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgInfo::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgInfo::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 MsgInfo::create_time() const {
  // @@protoc_insertion_point(field_get:Im.Base.MsgInfo.create_time)
  return create_time_;
}
inline void MsgInfo::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.MsgInfo.create_time)
}

// required .Im.Base.MsgType msg_type = 4;
inline bool MsgInfo::has_msg_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgInfo::set_has_msg_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgInfo::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgInfo::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::Im::Base::MsgType MsgInfo::msg_type() const {
  // @@protoc_insertion_point(field_get:Im.Base.MsgInfo.msg_type)
  return static_cast< ::Im::Base::MsgType >(msg_type_);
}
inline void MsgInfo::set_msg_type(::Im::Base::MsgType value) {
  assert(::Im::Base::MsgType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.MsgInfo.msg_type)
}

// required bytes msg_data = 5;
inline bool MsgInfo::has_msg_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgInfo::set_has_msg_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgInfo::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgInfo::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& MsgInfo::msg_data() const {
  // @@protoc_insertion_point(field_get:Im.Base.MsgInfo.msg_data)
  return *msg_data_;
}
inline void MsgInfo::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.MsgInfo.msg_data)
}
inline void MsgInfo::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.MsgInfo.msg_data)
}
inline void MsgInfo::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.MsgInfo.msg_data)
}
inline ::std::string* MsgInfo::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.MsgInfo.msg_data)
  return msg_data_;
}
inline ::std::string* MsgInfo::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgInfo::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.MsgInfo.msg_data)
}

// -------------------------------------------------------------------

// GroupVersionInfo

// required uint32 group_id = 1;
inline bool GroupVersionInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupVersionInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupVersionInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupVersionInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupVersionInfo::group_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.GroupVersionInfo.group_id)
  return group_id_;
}
inline void GroupVersionInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.GroupVersionInfo.group_id)
}

// required uint32 version = 2;
inline bool GroupVersionInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupVersionInfo::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupVersionInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupVersionInfo::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 GroupVersionInfo::version() const {
  // @@protoc_insertion_point(field_get:Im.Base.GroupVersionInfo.version)
  return version_;
}
inline void GroupVersionInfo::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.GroupVersionInfo.version)
}

// -------------------------------------------------------------------

// GroupInfo

// required uint32 group_id = 1;
inline bool GroupInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupInfo::group_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.GroupInfo.group_id)
  return group_id_;
}
inline void GroupInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.GroupInfo.group_id)
}

// required uint32 version = 2;
inline bool GroupInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupInfo::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupInfo::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 GroupInfo::version() const {
  // @@protoc_insertion_point(field_get:Im.Base.GroupInfo.version)
  return version_;
}
inline void GroupInfo::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.GroupInfo.version)
}

// required uint32 from_user_id = 3;
inline bool GroupInfo::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupInfo::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupInfo::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupInfo::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 GroupInfo::from_user_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.GroupInfo.from_user_id)
  return from_user_id_;
}
inline void GroupInfo::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.GroupInfo.from_user_id)
}

// required string group_name = 4;
inline bool GroupInfo::has_group_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupInfo::set_has_group_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupInfo::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupInfo::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& GroupInfo::group_name() const {
  // @@protoc_insertion_point(field_get:Im.Base.GroupInfo.group_name)
  return *group_name_;
}
inline void GroupInfo::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.GroupInfo.group_name)
}
inline void GroupInfo::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.GroupInfo.group_name)
}
inline void GroupInfo::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.GroupInfo.group_name)
}
inline ::std::string* GroupInfo::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.GroupInfo.group_name)
  return group_name_;
}
inline ::std::string* GroupInfo::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupInfo::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.GroupInfo.group_name)
}

// required string group_avatar = 5;
inline bool GroupInfo::has_group_avatar() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupInfo::set_has_group_avatar() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupInfo::clear_has_group_avatar() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupInfo::clear_group_avatar() {
  if (group_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_->clear();
  }
  clear_has_group_avatar();
}
inline const ::std::string& GroupInfo::group_avatar() const {
  // @@protoc_insertion_point(field_get:Im.Base.GroupInfo.group_avatar)
  return *group_avatar_;
}
inline void GroupInfo::set_group_avatar(const ::std::string& value) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.GroupInfo.group_avatar)
}
inline void GroupInfo::set_group_avatar(const char* value) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.GroupInfo.group_avatar)
}
inline void GroupInfo::set_group_avatar(const char* value, size_t size) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.GroupInfo.group_avatar)
}
inline ::std::string* GroupInfo::mutable_group_avatar() {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.GroupInfo.group_avatar)
  return group_avatar_;
}
inline ::std::string* GroupInfo::release_group_avatar() {
  clear_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_avatar_;
    group_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupInfo::set_allocated_group_avatar(::std::string* group_avatar) {
  if (group_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_avatar_;
  }
  if (group_avatar) {
    set_has_group_avatar();
    group_avatar_ = group_avatar;
  } else {
    clear_has_group_avatar();
    group_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.GroupInfo.group_avatar)
}

// required .Im.Base.GroupType group_type = 6;
inline bool GroupInfo::has_group_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupInfo::set_has_group_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupInfo::clear_has_group_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupInfo::clear_group_type() {
  group_type_ = 1;
  clear_has_group_type();
}
inline ::Im::Base::GroupType GroupInfo::group_type() const {
  // @@protoc_insertion_point(field_get:Im.Base.GroupInfo.group_type)
  return static_cast< ::Im::Base::GroupType >(group_type_);
}
inline void GroupInfo::set_group_type(::Im::Base::GroupType value) {
  assert(::Im::Base::GroupType_IsValid(value));
  set_has_group_type();
  group_type_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.GroupInfo.group_type)
}

// required uint32 shield_status = 7;
inline bool GroupInfo::has_shield_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupInfo::set_has_shield_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupInfo::clear_has_shield_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupInfo::clear_shield_status() {
  shield_status_ = 0u;
  clear_has_shield_status();
}
inline ::google::protobuf::uint32 GroupInfo::shield_status() const {
  // @@protoc_insertion_point(field_get:Im.Base.GroupInfo.shield_status)
  return shield_status_;
}
inline void GroupInfo::set_shield_status(::google::protobuf::uint32 value) {
  set_has_shield_status();
  shield_status_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.GroupInfo.shield_status)
}

// repeated uint32 group_member_list = 8;
inline int GroupInfo::group_member_list_size() const {
  return group_member_list_.size();
}
inline void GroupInfo::clear_group_member_list() {
  group_member_list_.Clear();
}
inline ::google::protobuf::uint32 GroupInfo::group_member_list(int index) const {
  // @@protoc_insertion_point(field_get:Im.Base.GroupInfo.group_member_list)
  return group_member_list_.Get(index);
}
inline void GroupInfo::set_group_member_list(int index, ::google::protobuf::uint32 value) {
  group_member_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Im.Base.GroupInfo.group_member_list)
}
inline void GroupInfo::add_group_member_list(::google::protobuf::uint32 value) {
  group_member_list_.Add(value);
  // @@protoc_insertion_point(field_add:Im.Base.GroupInfo.group_member_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GroupInfo::group_member_list() const {
  // @@protoc_insertion_point(field_list:Im.Base.GroupInfo.group_member_list)
  return group_member_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GroupInfo::mutable_group_member_list() {
  // @@protoc_insertion_point(field_mutable_list:Im.Base.GroupInfo.group_member_list)
  return &group_member_list_;
}

// -------------------------------------------------------------------

// UserTokenInfo

// required uint32 user_id = 1;
inline bool UserTokenInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTokenInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTokenInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTokenInfo::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserTokenInfo::user_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserTokenInfo.user_id)
  return user_id_;
}
inline void UserTokenInfo::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UserTokenInfo.user_id)
}

// required .Im.Base.ClientType client_type = 2;
inline bool UserTokenInfo::has_client_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTokenInfo::set_has_client_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTokenInfo::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTokenInfo::clear_client_type() {
  client_type_ = 1;
  clear_has_client_type();
}
inline ::Im::Base::ClientType UserTokenInfo::client_type() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserTokenInfo.client_type)
  return static_cast< ::Im::Base::ClientType >(client_type_);
}
inline void UserTokenInfo::set_client_type(::Im::Base::ClientType value) {
  assert(::Im::Base::ClientType_IsValid(value));
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UserTokenInfo.client_type)
}

// required string token = 3;
inline bool UserTokenInfo::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserTokenInfo::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserTokenInfo::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserTokenInfo::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UserTokenInfo::token() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserTokenInfo.token)
  return *token_;
}
inline void UserTokenInfo::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.UserTokenInfo.token)
}
inline void UserTokenInfo::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.UserTokenInfo.token)
}
inline void UserTokenInfo::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.UserTokenInfo.token)
}
inline ::std::string* UserTokenInfo::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.UserTokenInfo.token)
  return token_;
}
inline ::std::string* UserTokenInfo::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserTokenInfo::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.UserTokenInfo.token)
}

// required uint32 push_count = 4;
inline bool UserTokenInfo::has_push_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserTokenInfo::set_has_push_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserTokenInfo::clear_has_push_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserTokenInfo::clear_push_count() {
  push_count_ = 0u;
  clear_has_push_count();
}
inline ::google::protobuf::uint32 UserTokenInfo::push_count() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserTokenInfo.push_count)
  return push_count_;
}
inline void UserTokenInfo::set_push_count(::google::protobuf::uint32 value) {
  set_has_push_count();
  push_count_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UserTokenInfo.push_count)
}

// required uint32 push_type = 5;
inline bool UserTokenInfo::has_push_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserTokenInfo::set_has_push_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserTokenInfo::clear_has_push_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserTokenInfo::clear_push_type() {
  push_type_ = 0u;
  clear_has_push_type();
}
inline ::google::protobuf::uint32 UserTokenInfo::push_type() const {
  // @@protoc_insertion_point(field_get:Im.Base.UserTokenInfo.push_type)
  return push_type_;
}
inline void UserTokenInfo::set_push_type(::google::protobuf::uint32 value) {
  set_has_push_type();
  push_type_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.UserTokenInfo.push_type)
}

// -------------------------------------------------------------------

// PushResult

// required string user_token = 1;
inline bool PushResult::has_user_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushResult::set_has_user_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushResult::clear_has_user_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushResult::clear_user_token() {
  if (user_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_->clear();
  }
  clear_has_user_token();
}
inline const ::std::string& PushResult::user_token() const {
  // @@protoc_insertion_point(field_get:Im.Base.PushResult.user_token)
  return *user_token_;
}
inline void PushResult::set_user_token(const ::std::string& value) {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  user_token_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.PushResult.user_token)
}
inline void PushResult::set_user_token(const char* value) {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  user_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.PushResult.user_token)
}
inline void PushResult::set_user_token(const char* value, size_t size) {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  user_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.PushResult.user_token)
}
inline ::std::string* PushResult::mutable_user_token() {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.PushResult.user_token)
  return user_token_;
}
inline ::std::string* PushResult::release_user_token() {
  clear_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_token_;
    user_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushResult::set_allocated_user_token(::std::string* user_token) {
  if (user_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_token_;
  }
  if (user_token) {
    set_has_user_token();
    user_token_ = user_token;
  } else {
    clear_has_user_token();
    user_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.PushResult.user_token)
}

// required uint32 result_code = 2;
inline bool PushResult::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushResult::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushResult::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushResult::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 PushResult::result_code() const {
  // @@protoc_insertion_point(field_get:Im.Base.PushResult.result_code)
  return result_code_;
}
inline void PushResult::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.PushResult.result_code)
}

// -------------------------------------------------------------------

// ShieldStatus

// required uint32 user_id = 1;
inline bool ShieldStatus::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShieldStatus::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShieldStatus::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShieldStatus::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 ShieldStatus::user_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.ShieldStatus.user_id)
  return user_id_;
}
inline void ShieldStatus::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ShieldStatus.user_id)
}

// required uint32 group_id = 2;
inline bool ShieldStatus::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShieldStatus::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShieldStatus::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShieldStatus::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 ShieldStatus::group_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.ShieldStatus.group_id)
  return group_id_;
}
inline void ShieldStatus::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ShieldStatus.group_id)
}

// required uint32 shield_status = 3;
inline bool ShieldStatus::has_shield_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShieldStatus::set_has_shield_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShieldStatus::clear_has_shield_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShieldStatus::clear_shield_status() {
  shield_status_ = 0u;
  clear_has_shield_status();
}
inline ::google::protobuf::uint32 ShieldStatus::shield_status() const {
  // @@protoc_insertion_point(field_get:Im.Base.ShieldStatus.shield_status)
  return shield_status_;
}
inline void ShieldStatus::set_shield_status(::google::protobuf::uint32 value) {
  set_has_shield_status();
  shield_status_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.ShieldStatus.shield_status)
}

// -------------------------------------------------------------------

// OfflineFileInfo

// required uint32 from_user_id = 1;
inline bool OfflineFileInfo::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfflineFileInfo::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfflineFileInfo::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfflineFileInfo::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 OfflineFileInfo::from_user_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.OfflineFileInfo.from_user_id)
  return from_user_id_;
}
inline void OfflineFileInfo::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Base.OfflineFileInfo.from_user_id)
}

// required string task_id = 2;
inline bool OfflineFileInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OfflineFileInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OfflineFileInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OfflineFileInfo::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& OfflineFileInfo::task_id() const {
  // @@protoc_insertion_point(field_get:Im.Base.OfflineFileInfo.task_id)
  return *task_id_;
}
inline void OfflineFileInfo::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.OfflineFileInfo.task_id)
}
inline void OfflineFileInfo::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.OfflineFileInfo.task_id)
}
inline void OfflineFileInfo::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.OfflineFileInfo.task_id)
}
inline ::std::string* OfflineFileInfo::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.OfflineFileInfo.task_id)
  return task_id_;
}
inline ::std::string* OfflineFileInfo::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OfflineFileInfo::set_allocated_task_id(::std::string* task_id) {
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete task_id_;
  }
  if (task_id) {
    set_has_task_id();
    task_id_ = task_id;
  } else {
    clear_has_task_id();
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.OfflineFileInfo.task_id)
}

// required string file_name = 3;
inline bool OfflineFileInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OfflineFileInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OfflineFileInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OfflineFileInfo::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& OfflineFileInfo::file_name() const {
  // @@protoc_insertion_point(field_get:Im.Base.OfflineFileInfo.file_name)
  return *file_name_;
}
inline void OfflineFileInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.OfflineFileInfo.file_name)
}
inline void OfflineFileInfo::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.OfflineFileInfo.file_name)
}
inline void OfflineFileInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.OfflineFileInfo.file_name)
}
inline ::std::string* OfflineFileInfo::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.OfflineFileInfo.file_name)
  return file_name_;
}
inline ::std::string* OfflineFileInfo::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OfflineFileInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.OfflineFileInfo.file_name)
}

// required string file_size = 4;
inline bool OfflineFileInfo::has_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OfflineFileInfo::set_has_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OfflineFileInfo::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OfflineFileInfo::clear_file_size() {
  if (file_size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_size_->clear();
  }
  clear_has_file_size();
}
inline const ::std::string& OfflineFileInfo::file_size() const {
  // @@protoc_insertion_point(field_get:Im.Base.OfflineFileInfo.file_size)
  return *file_size_;
}
inline void OfflineFileInfo::set_file_size(const ::std::string& value) {
  set_has_file_size();
  if (file_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_size_ = new ::std::string;
  }
  file_size_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Base.OfflineFileInfo.file_size)
}
inline void OfflineFileInfo::set_file_size(const char* value) {
  set_has_file_size();
  if (file_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_size_ = new ::std::string;
  }
  file_size_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Base.OfflineFileInfo.file_size)
}
inline void OfflineFileInfo::set_file_size(const char* value, size_t size) {
  set_has_file_size();
  if (file_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_size_ = new ::std::string;
  }
  file_size_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Base.OfflineFileInfo.file_size)
}
inline ::std::string* OfflineFileInfo::mutable_file_size() {
  set_has_file_size();
  if (file_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_size_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Base.OfflineFileInfo.file_size)
  return file_size_;
}
inline ::std::string* OfflineFileInfo::release_file_size() {
  clear_has_file_size();
  if (file_size_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_size_;
    file_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OfflineFileInfo::set_allocated_file_size(::std::string* file_size) {
  if (file_size_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_size_;
  }
  if (file_size) {
    set_has_file_size();
    file_size_ = file_size;
  } else {
    clear_has_file_size();
    file_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Base.OfflineFileInfo.file_size)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Base
}  // namespace Im

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Im::Base::Service> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::Service>() {
  return ::Im::Base::Service_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::LoginCommand> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::LoginCommand>() {
  return ::Im::Base::LoginCommand_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::BuddyListCommand> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::BuddyListCommand>() {
  return ::Im::Base::BuddyListCommand_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::MessageCommand> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::MessageCommand>() {
  return ::Im::Base::MessageCommand_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::GroupCommand> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::GroupCommand>() {
  return ::Im::Base::GroupCommand_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::FileCommand> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::FileCommand>() {
  return ::Im::Base::FileCommand_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::SwitchCommand> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::SwitchCommand>() {
  return ::Im::Base::SwitchCommand_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::OtherCommand> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::OtherCommand>() {
  return ::Im::Base::OtherCommand_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::SessionCmd> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::SessionCmd>() {
  return ::Im::Base::SessionCmd_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::UserCmd> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::UserCmd>() {
  return ::Im::Base::UserCmd_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::ResultType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::ResultType>() {
  return ::Im::Base::ResultType_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::KickReasonType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::KickReasonType>() {
  return ::Im::Base::KickReasonType_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::OnlineListType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::OnlineListType>() {
  return ::Im::Base::OnlineListType_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::UserStatusType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::UserStatusType>() {
  return ::Im::Base::UserStatusType_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::SessionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::SessionType>() {
  return ::Im::Base::SessionType_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::MsgType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::MsgType>() {
  return ::Im::Base::MsgType_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::ClientType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::ClientType>() {
  return ::Im::Base::ClientType_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::GroupType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::GroupType>() {
  return ::Im::Base::GroupType_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::GroupModifyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::GroupModifyType>() {
  return ::Im::Base::GroupModifyType_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::FileType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::FileType>() {
  return ::Im::Base::FileType_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::ClientFileStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::ClientFileStatus>() {
  return ::Im::Base::ClientFileStatus_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::ClientFileRole> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::ClientFileRole>() {
  return ::Im::Base::ClientFileRole_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::FileServerError> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::FileServerError>() {
  return ::Im::Base::FileServerError_descriptor();
}
template <> struct is_proto_enum< ::Im::Base::SessionStatusType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Im::Base::SessionStatusType>() {
  return ::Im::Base::SessionStatusType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Im_2eBase_2eproto__INCLUDED
