// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Im.Server.proto

#ifndef PROTOBUF_Im_2eServer_2eproto__INCLUDED
#define PROTOBUF_Im_2eServer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "Im.Base.pb.h"
// @@protoc_insertion_point(includes)

namespace Im {
namespace Server {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Im_2eServer_2eproto();
void protobuf_AssignDesc_Im_2eServer_2eproto();
void protobuf_ShutdownFile_Im_2eServer_2eproto();

class ServerRequest;
class ServerResponse;
class StopReceivePacket;
class ValidateRequest;
class ValidateResponse;
class GetDeviceTokenRequest;
class GetDeviceTokenResponse;
class RoleSet;
class OnlineUserInfo;
class MsgServerInfo;
class ServerInfo;
class UserStatusUpdate;
class UserCountUpdate;
class ServerUpdateNotity;
class ServerKickUser;
class ServerPcLoginStatusNotify;
class PushToUserRequest;
class PushToUserRepsonse;
class GroupGetShieldRequest;
class GroupGetShieldResponse;
class FileTransferRequest;
class FileTransferResponse;
class FileServerIpRequest;
class FileServerIpResponse;

// ===================================================================

class ServerRequest : public ::google::protobuf::Message {
 public:
  ServerRequest();
  virtual ~ServerRequest();

  ServerRequest(const ServerRequest& from);

  inline ServerRequest& operator=(const ServerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerRequest& default_instance();

  void Swap(ServerRequest* other);

  // implements Message ----------------------------------------------

  ServerRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerRequest& from);
  void MergeFrom(const ServerRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Im.Server.ServerRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static ServerRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServerResponse : public ::google::protobuf::Message {
 public:
  ServerResponse();
  virtual ~ServerResponse();

  ServerResponse(const ServerResponse& from);

  inline ServerResponse& operator=(const ServerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerResponse& default_instance();

  void Swap(ServerResponse* other);

  // implements Message ----------------------------------------------

  ServerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerResponse& from);
  void MergeFrom(const ServerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Im.Base.ResultType result_type = 1;
  inline bool has_result_type() const;
  inline void clear_result_type();
  static const int kResultTypeFieldNumber = 1;
  inline ::Im::Base::ResultType result_type() const;
  inline void set_result_type(::Im::Base::ResultType value);

  // optional string priority = 2;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 2;
  inline const ::std::string& priority() const;
  inline void set_priority(const ::std::string& value);
  inline void set_priority(const char* value);
  inline void set_priority(const char* value, size_t size);
  inline ::std::string* mutable_priority();
  inline ::std::string* release_priority();
  inline void set_allocated_priority(::std::string* priority);

  // optional string backup = 3;
  inline bool has_backup() const;
  inline void clear_backup();
  static const int kBackupFieldNumber = 3;
  inline const ::std::string& backup() const;
  inline void set_backup(const ::std::string& value);
  inline void set_backup(const char* value);
  inline void set_backup(const char* value, size_t size);
  inline ::std::string* mutable_backup();
  inline ::std::string* release_backup();
  inline void set_allocated_backup(::std::string* backup);

  // optional uint32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Server.ServerResponse)
 private:
  inline void set_has_result_type();
  inline void clear_has_result_type();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_backup();
  inline void clear_has_backup();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* priority_;
  int result_type_;
  ::google::protobuf::uint32 port_;
  ::std::string* backup_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static ServerResponse* default_instance_;
};
// -------------------------------------------------------------------

class StopReceivePacket : public ::google::protobuf::Message {
 public:
  StopReceivePacket();
  virtual ~StopReceivePacket();

  StopReceivePacket(const StopReceivePacket& from);

  inline StopReceivePacket& operator=(const StopReceivePacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopReceivePacket& default_instance();

  void Swap(StopReceivePacket* other);

  // implements Message ----------------------------------------------

  StopReceivePacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopReceivePacket& from);
  void MergeFrom(const StopReceivePacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Server.StopReceivePacket)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static StopReceivePacket* default_instance_;
};
// -------------------------------------------------------------------

class ValidateRequest : public ::google::protobuf::Message {
 public:
  ValidateRequest();
  virtual ~ValidateRequest();

  ValidateRequest(const ValidateRequest& from);

  inline ValidateRequest& operator=(const ValidateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidateRequest& default_instance();

  void Swap(ValidateRequest* other);

  // implements Message ----------------------------------------------

  ValidateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ValidateRequest& from);
  void MergeFrom(const ValidateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required string user_password = 2;
  inline bool has_user_password() const;
  inline void clear_user_password();
  static const int kUserPasswordFieldNumber = 2;
  inline const ::std::string& user_password() const;
  inline void set_user_password(const ::std::string& value);
  inline void set_user_password(const char* value);
  inline void set_user_password(const char* value, size_t size);
  inline ::std::string* mutable_user_password();
  inline ::std::string* release_user_password();
  inline void set_allocated_user_password(::std::string* user_password);

  // optional bytes attach_data = 3;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 3;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:Im.Server.ValidateRequest)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_user_password();
  inline void clear_has_user_password();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_name_;
  ::std::string* user_password_;
  ::std::string* attach_data_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static ValidateRequest* default_instance_;
};
// -------------------------------------------------------------------

class ValidateResponse : public ::google::protobuf::Message {
 public:
  ValidateResponse();
  virtual ~ValidateResponse();

  ValidateResponse(const ValidateResponse& from);

  inline ValidateResponse& operator=(const ValidateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidateResponse& default_instance();

  void Swap(ValidateResponse* other);

  // implements Message ----------------------------------------------

  ValidateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ValidateResponse& from);
  void MergeFrom(const ValidateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // optional string result_string = 3;
  inline bool has_result_string() const;
  inline void clear_result_string();
  static const int kResultStringFieldNumber = 3;
  inline const ::std::string& result_string() const;
  inline void set_result_string(const ::std::string& value);
  inline void set_result_string(const char* value);
  inline void set_result_string(const char* value, size_t size);
  inline ::std::string* mutable_result_string();
  inline ::std::string* release_result_string();
  inline void set_allocated_result_string(::std::string* result_string);

  // optional .Im.Base.UserInfo user_info = 4;
  inline bool has_user_info() const;
  inline void clear_user_info();
  static const int kUserInfoFieldNumber = 4;
  inline const ::Im::Base::UserInfo& user_info() const;
  inline ::Im::Base::UserInfo* mutable_user_info();
  inline ::Im::Base::UserInfo* release_user_info();
  inline void set_allocated_user_info(::Im::Base::UserInfo* user_info);

  // optional bytes attach_data = 5;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 5;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:Im.Server.ValidateResponse)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_result_string();
  inline void clear_has_result_string();
  inline void set_has_user_info();
  inline void clear_has_user_info();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_name_;
  ::std::string* result_string_;
  ::Im::Base::UserInfo* user_info_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 result_code_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static ValidateResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetDeviceTokenRequest : public ::google::protobuf::Message {
 public:
  GetDeviceTokenRequest();
  virtual ~GetDeviceTokenRequest();

  GetDeviceTokenRequest(const GetDeviceTokenRequest& from);

  inline GetDeviceTokenRequest& operator=(const GetDeviceTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDeviceTokenRequest& default_instance();

  void Swap(GetDeviceTokenRequest* other);

  // implements Message ----------------------------------------------

  GetDeviceTokenRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDeviceTokenRequest& from);
  void MergeFrom(const GetDeviceTokenRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 user_id = 1;
  inline int user_id_size() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id(int index) const;
  inline void set_user_id(int index, ::google::protobuf::uint32 value);
  inline void add_user_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id();

  // optional bytes attach_data = 2;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 2;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:Im.Server.GetDeviceTokenRequest)
 private:
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_;
  ::std::string* attach_data_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static GetDeviceTokenRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetDeviceTokenResponse : public ::google::protobuf::Message {
 public:
  GetDeviceTokenResponse();
  virtual ~GetDeviceTokenResponse();

  GetDeviceTokenResponse(const GetDeviceTokenResponse& from);

  inline GetDeviceTokenResponse& operator=(const GetDeviceTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDeviceTokenResponse& default_instance();

  void Swap(GetDeviceTokenResponse* other);

  // implements Message ----------------------------------------------

  GetDeviceTokenResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDeviceTokenResponse& from);
  void MergeFrom(const GetDeviceTokenResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Im.Base.UserTokenInfo user_token_info = 1;
  inline int user_token_info_size() const;
  inline void clear_user_token_info();
  static const int kUserTokenInfoFieldNumber = 1;
  inline const ::Im::Base::UserTokenInfo& user_token_info(int index) const;
  inline ::Im::Base::UserTokenInfo* mutable_user_token_info(int index);
  inline ::Im::Base::UserTokenInfo* add_user_token_info();
  inline const ::google::protobuf::RepeatedPtrField< ::Im::Base::UserTokenInfo >&
      user_token_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::Im::Base::UserTokenInfo >*
      mutable_user_token_info();

  // optional bytes attach_data = 2;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 2;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:Im.Server.GetDeviceTokenResponse)
 private:
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Im::Base::UserTokenInfo > user_token_info_;
  ::std::string* attach_data_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static GetDeviceTokenResponse* default_instance_;
};
// -------------------------------------------------------------------

class RoleSet : public ::google::protobuf::Message {
 public:
  RoleSet();
  virtual ~RoleSet();

  RoleSet(const RoleSet& from);

  inline RoleSet& operator=(const RoleSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleSet& default_instance();

  void Swap(RoleSet* other);

  // implements Message ----------------------------------------------

  RoleSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleSet& from);
  void MergeFrom(const RoleSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 master_id = 1;
  inline bool has_master_id() const;
  inline void clear_master_id();
  static const int kMasterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 master_id() const;
  inline void set_master_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Server.RoleSet)
 private:
  inline void set_has_master_id();
  inline void clear_has_master_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 master_id_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static RoleSet* default_instance_;
};
// -------------------------------------------------------------------

class OnlineUserInfo : public ::google::protobuf::Message {
 public:
  OnlineUserInfo();
  virtual ~OnlineUserInfo();

  OnlineUserInfo(const OnlineUserInfo& from);

  inline OnlineUserInfo& operator=(const OnlineUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlineUserInfo& default_instance();

  void Swap(OnlineUserInfo* other);

  // implements Message ----------------------------------------------

  OnlineUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlineUserInfo& from);
  void MergeFrom(const OnlineUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Im.Base.ServerUserStatus user_status_list = 1;
  inline int user_status_list_size() const;
  inline void clear_user_status_list();
  static const int kUserStatusListFieldNumber = 1;
  inline const ::Im::Base::ServerUserStatus& user_status_list(int index) const;
  inline ::Im::Base::ServerUserStatus* mutable_user_status_list(int index);
  inline ::Im::Base::ServerUserStatus* add_user_status_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Im::Base::ServerUserStatus >&
      user_status_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Im::Base::ServerUserStatus >*
      mutable_user_status_list();

  // @@protoc_insertion_point(class_scope:Im.Server.OnlineUserInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Im::Base::ServerUserStatus > user_status_list_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static OnlineUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class MsgServerInfo : public ::google::protobuf::Message {
 public:
  MsgServerInfo();
  virtual ~MsgServerInfo();

  MsgServerInfo(const MsgServerInfo& from);

  inline MsgServerInfo& operator=(const MsgServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgServerInfo& default_instance();

  void Swap(MsgServerInfo* other);

  // implements Message ----------------------------------------------

  MsgServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgServerInfo& from);
  void MergeFrom(const MsgServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip_1 = 1;
  inline bool has_ip_1() const;
  inline void clear_ip_1();
  static const int kIp1FieldNumber = 1;
  inline const ::std::string& ip_1() const;
  inline void set_ip_1(const ::std::string& value);
  inline void set_ip_1(const char* value);
  inline void set_ip_1(const char* value, size_t size);
  inline ::std::string* mutable_ip_1();
  inline ::std::string* release_ip_1();
  inline void set_allocated_ip_1(::std::string* ip_1);

  // required string ip_2 = 2;
  inline bool has_ip_2() const;
  inline void clear_ip_2();
  static const int kIp2FieldNumber = 2;
  inline const ::std::string& ip_2() const;
  inline void set_ip_2(const ::std::string& value);
  inline void set_ip_2(const char* value);
  inline void set_ip_2(const char* value, size_t size);
  inline ::std::string* mutable_ip_2();
  inline ::std::string* release_ip_2();
  inline void set_allocated_ip_2(::std::string* ip_2);

  // required uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required string host_name = 4;
  inline bool has_host_name() const;
  inline void clear_host_name();
  static const int kHostNameFieldNumber = 4;
  inline const ::std::string& host_name() const;
  inline void set_host_name(const ::std::string& value);
  inline void set_host_name(const char* value);
  inline void set_host_name(const char* value, size_t size);
  inline ::std::string* mutable_host_name();
  inline ::std::string* release_host_name();
  inline void set_allocated_host_name(::std::string* host_name);

  // required uint32 max_connect_cnt = 5;
  inline bool has_max_connect_cnt() const;
  inline void clear_max_connect_cnt();
  static const int kMaxConnectCntFieldNumber = 5;
  inline ::google::protobuf::uint32 max_connect_cnt() const;
  inline void set_max_connect_cnt(::google::protobuf::uint32 value);

  // required uint32 current_connect_cnt = 6;
  inline bool has_current_connect_cnt() const;
  inline void clear_current_connect_cnt();
  static const int kCurrentConnectCntFieldNumber = 6;
  inline ::google::protobuf::uint32 current_connect_cnt() const;
  inline void set_current_connect_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Server.MsgServerInfo)
 private:
  inline void set_has_ip_1();
  inline void clear_has_ip_1();
  inline void set_has_ip_2();
  inline void clear_has_ip_2();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_host_name();
  inline void clear_has_host_name();
  inline void set_has_max_connect_cnt();
  inline void clear_has_max_connect_cnt();
  inline void set_has_current_connect_cnt();
  inline void clear_has_current_connect_cnt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_1_;
  ::std::string* ip_2_;
  ::std::string* host_name_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 max_connect_cnt_;
  ::google::protobuf::uint32 current_connect_cnt_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static MsgServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class ServerInfo : public ::google::protobuf::Message {
 public:
  ServerInfo();
  virtual ~ServerInfo();

  ServerInfo(const ServerInfo& from);

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfo& default_instance();

  void Swap(ServerInfo* other);

  // implements Message ----------------------------------------------

  ServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerInfo& from);
  void MergeFrom(const ServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip_1 = 1;
  inline bool has_ip_1() const;
  inline void clear_ip_1();
  static const int kIp1FieldNumber = 1;
  inline const ::std::string& ip_1() const;
  inline void set_ip_1(const ::std::string& value);
  inline void set_ip_1(const char* value);
  inline void set_ip_1(const char* value, size_t size);
  inline ::std::string* mutable_ip_1();
  inline ::std::string* release_ip_1();
  inline void set_allocated_ip_1(::std::string* ip_1);

  // required string ip_2 = 2;
  inline bool has_ip_2() const;
  inline void clear_ip_2();
  static const int kIp2FieldNumber = 2;
  inline const ::std::string& ip_2() const;
  inline void set_ip_2(const ::std::string& value);
  inline void set_ip_2(const char* value);
  inline void set_ip_2(const char* value, size_t size);
  inline ::std::string* mutable_ip_2();
  inline ::std::string* release_ip_2();
  inline void set_allocated_ip_2(::std::string* ip_2);

  // required uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required string host_name = 4;
  inline bool has_host_name() const;
  inline void clear_host_name();
  static const int kHostNameFieldNumber = 4;
  inline const ::std::string& host_name() const;
  inline void set_host_name(const ::std::string& value);
  inline void set_host_name(const char* value);
  inline void set_host_name(const char* value, size_t size);
  inline ::std::string* mutable_host_name();
  inline ::std::string* release_host_name();
  inline void set_allocated_host_name(::std::string* host_name);

  // required uint32 max_connect_cnt = 5;
  inline bool has_max_connect_cnt() const;
  inline void clear_max_connect_cnt();
  static const int kMaxConnectCntFieldNumber = 5;
  inline ::google::protobuf::uint32 max_connect_cnt() const;
  inline void set_max_connect_cnt(::google::protobuf::uint32 value);

  // required uint32 cur_connect_cnt = 6;
  inline bool has_cur_connect_cnt() const;
  inline void clear_cur_connect_cnt();
  static const int kCurConnectCntFieldNumber = 6;
  inline ::google::protobuf::uint32 cur_connect_cnt() const;
  inline void set_cur_connect_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Server.ServerInfo)
 private:
  inline void set_has_ip_1();
  inline void clear_has_ip_1();
  inline void set_has_ip_2();
  inline void clear_has_ip_2();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_host_name();
  inline void clear_has_host_name();
  inline void set_has_max_connect_cnt();
  inline void clear_has_max_connect_cnt();
  inline void set_has_cur_connect_cnt();
  inline void clear_has_cur_connect_cnt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_1_;
  ::std::string* ip_2_;
  ::std::string* host_name_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 max_connect_cnt_;
  ::google::protobuf::uint32 cur_connect_cnt_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static ServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserStatusUpdate : public ::google::protobuf::Message {
 public:
  UserStatusUpdate();
  virtual ~UserStatusUpdate();

  UserStatusUpdate(const UserStatusUpdate& from);

  inline UserStatusUpdate& operator=(const UserStatusUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserStatusUpdate& default_instance();

  void Swap(UserStatusUpdate* other);

  // implements Message ----------------------------------------------

  UserStatusUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserStatusUpdate& from);
  void MergeFrom(const UserStatusUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_status = 1;
  inline bool has_user_status() const;
  inline void clear_user_status();
  static const int kUserStatusFieldNumber = 1;
  inline ::google::protobuf::uint32 user_status() const;
  inline void set_user_status(::google::protobuf::uint32 value);

  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .Im.Base.ClientType client_type = 3;
  inline bool has_client_type() const;
  inline void clear_client_type();
  static const int kClientTypeFieldNumber = 3;
  inline ::Im::Base::ClientType client_type() const;
  inline void set_client_type(::Im::Base::ClientType value);

  // @@protoc_insertion_point(class_scope:Im.Server.UserStatusUpdate)
 private:
  inline void set_has_user_status();
  inline void clear_has_user_status();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_client_type();
  inline void clear_has_client_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_status_;
  ::google::protobuf::uint32 user_id_;
  int client_type_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static UserStatusUpdate* default_instance_;
};
// -------------------------------------------------------------------

class UserCountUpdate : public ::google::protobuf::Message {
 public:
  UserCountUpdate();
  virtual ~UserCountUpdate();

  UserCountUpdate(const UserCountUpdate& from);

  inline UserCountUpdate& operator=(const UserCountUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserCountUpdate& default_instance();

  void Swap(UserCountUpdate* other);

  // implements Message ----------------------------------------------

  UserCountUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserCountUpdate& from);
  void MergeFrom(const UserCountUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_action = 1;
  inline bool has_user_action() const;
  inline void clear_user_action();
  static const int kUserActionFieldNumber = 1;
  inline ::google::protobuf::uint32 user_action() const;
  inline void set_user_action(::google::protobuf::uint32 value);

  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Server.UserCountUpdate)
 private:
  inline void set_has_user_action();
  inline void clear_has_user_action();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_action_;
  ::google::protobuf::uint32 user_id_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static UserCountUpdate* default_instance_;
};
// -------------------------------------------------------------------

class ServerUpdateNotity : public ::google::protobuf::Message {
 public:
  ServerUpdateNotity();
  virtual ~ServerUpdateNotity();

  ServerUpdateNotity(const ServerUpdateNotity& from);

  inline ServerUpdateNotity& operator=(const ServerUpdateNotity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerUpdateNotity& default_instance();

  void Swap(ServerUpdateNotity* other);

  // implements Message ----------------------------------------------

  ServerUpdateNotity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerUpdateNotity& from);
  void MergeFrom(const ServerUpdateNotity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::google::protobuf::uint32 action() const;
  inline void set_action(::google::protobuf::uint32 value);

  // required uint32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Server.ServerUpdateNotity)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 action_;
  ::google::protobuf::uint32 user_id_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static ServerUpdateNotity* default_instance_;
};
// -------------------------------------------------------------------

class ServerKickUser : public ::google::protobuf::Message {
 public:
  ServerKickUser();
  virtual ~ServerKickUser();

  ServerKickUser(const ServerKickUser& from);

  inline ServerKickUser& operator=(const ServerKickUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerKickUser& default_instance();

  void Swap(ServerKickUser* other);

  // implements Message ----------------------------------------------

  ServerKickUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerKickUser& from);
  void MergeFrom(const ServerKickUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .Im.Base.ClientType client_type = 2;
  inline bool has_client_type() const;
  inline void clear_client_type();
  static const int kClientTypeFieldNumber = 2;
  inline ::Im::Base::ClientType client_type() const;
  inline void set_client_type(::Im::Base::ClientType value);

  // required uint32 reason = 3;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 3;
  inline ::google::protobuf::uint32 reason() const;
  inline void set_reason(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Server.ServerKickUser)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_client_type();
  inline void clear_has_client_type();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int client_type_;
  ::google::protobuf::uint32 reason_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static ServerKickUser* default_instance_;
};
// -------------------------------------------------------------------

class ServerPcLoginStatusNotify : public ::google::protobuf::Message {
 public:
  ServerPcLoginStatusNotify();
  virtual ~ServerPcLoginStatusNotify();

  ServerPcLoginStatusNotify(const ServerPcLoginStatusNotify& from);

  inline ServerPcLoginStatusNotify& operator=(const ServerPcLoginStatusNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerPcLoginStatusNotify& default_instance();

  void Swap(ServerPcLoginStatusNotify* other);

  // implements Message ----------------------------------------------

  ServerPcLoginStatusNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerPcLoginStatusNotify& from);
  void MergeFrom(const ServerPcLoginStatusNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 login_status = 2;
  inline bool has_login_status() const;
  inline void clear_login_status();
  static const int kLoginStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 login_status() const;
  inline void set_login_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Im.Server.ServerPcLoginStatusNotify)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_login_status();
  inline void clear_has_login_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 login_status_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static ServerPcLoginStatusNotify* default_instance_;
};
// -------------------------------------------------------------------

class PushToUserRequest : public ::google::protobuf::Message {
 public:
  PushToUserRequest();
  virtual ~PushToUserRequest();

  PushToUserRequest(const PushToUserRequest& from);

  inline PushToUserRequest& operator=(const PushToUserRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PushToUserRequest& default_instance();

  void Swap(PushToUserRequest* other);

  // implements Message ----------------------------------------------

  PushToUserRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PushToUserRequest& from);
  void MergeFrom(const PushToUserRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string flash = 1;
  inline bool has_flash() const;
  inline void clear_flash();
  static const int kFlashFieldNumber = 1;
  inline const ::std::string& flash() const;
  inline void set_flash(const ::std::string& value);
  inline void set_flash(const char* value);
  inline void set_flash(const char* value, size_t size);
  inline ::std::string* mutable_flash();
  inline ::std::string* release_flash();
  inline void set_allocated_flash(::std::string* flash);

  // required string data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // repeated .Im.Base.UserTokenInfo user_token_list = 3;
  inline int user_token_list_size() const;
  inline void clear_user_token_list();
  static const int kUserTokenListFieldNumber = 3;
  inline const ::Im::Base::UserTokenInfo& user_token_list(int index) const;
  inline ::Im::Base::UserTokenInfo* mutable_user_token_list(int index);
  inline ::Im::Base::UserTokenInfo* add_user_token_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Im::Base::UserTokenInfo >&
      user_token_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Im::Base::UserTokenInfo >*
      mutable_user_token_list();

  // @@protoc_insertion_point(class_scope:Im.Server.PushToUserRequest)
 private:
  inline void set_has_flash();
  inline void clear_has_flash();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* flash_;
  ::std::string* data_;
  ::google::protobuf::RepeatedPtrField< ::Im::Base::UserTokenInfo > user_token_list_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static PushToUserRequest* default_instance_;
};
// -------------------------------------------------------------------

class PushToUserRepsonse : public ::google::protobuf::Message {
 public:
  PushToUserRepsonse();
  virtual ~PushToUserRepsonse();

  PushToUserRepsonse(const PushToUserRepsonse& from);

  inline PushToUserRepsonse& operator=(const PushToUserRepsonse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PushToUserRepsonse& default_instance();

  void Swap(PushToUserRepsonse* other);

  // implements Message ----------------------------------------------

  PushToUserRepsonse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PushToUserRepsonse& from);
  void MergeFrom(const PushToUserRepsonse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Im.Base.PushResult push_result_list = 1;
  inline int push_result_list_size() const;
  inline void clear_push_result_list();
  static const int kPushResultListFieldNumber = 1;
  inline const ::Im::Base::PushResult& push_result_list(int index) const;
  inline ::Im::Base::PushResult* mutable_push_result_list(int index);
  inline ::Im::Base::PushResult* add_push_result_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Im::Base::PushResult >&
      push_result_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Im::Base::PushResult >*
      mutable_push_result_list();

  // @@protoc_insertion_point(class_scope:Im.Server.PushToUserRepsonse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Im::Base::PushResult > push_result_list_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static PushToUserRepsonse* default_instance_;
};
// -------------------------------------------------------------------

class GroupGetShieldRequest : public ::google::protobuf::Message {
 public:
  GroupGetShieldRequest();
  virtual ~GroupGetShieldRequest();

  GroupGetShieldRequest(const GroupGetShieldRequest& from);

  inline GroupGetShieldRequest& operator=(const GroupGetShieldRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupGetShieldRequest& default_instance();

  void Swap(GroupGetShieldRequest* other);

  // implements Message ----------------------------------------------

  GroupGetShieldRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupGetShieldRequest& from);
  void MergeFrom(const GroupGetShieldRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // repeated uint32 user_id = 2;
  inline int user_id_size() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 user_id(int index) const;
  inline void set_user_id(int index, ::google::protobuf::uint32 value);
  inline void add_user_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      user_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_user_id();

  // optional bytes attach_data = 3;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 3;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:Im.Server.GroupGetShieldRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > user_id_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 group_id_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static GroupGetShieldRequest* default_instance_;
};
// -------------------------------------------------------------------

class GroupGetShieldResponse : public ::google::protobuf::Message {
 public:
  GroupGetShieldResponse();
  virtual ~GroupGetShieldResponse();

  GroupGetShieldResponse(const GroupGetShieldResponse& from);

  inline GroupGetShieldResponse& operator=(const GroupGetShieldResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupGetShieldResponse& default_instance();

  void Swap(GroupGetShieldResponse* other);

  // implements Message ----------------------------------------------

  GroupGetShieldResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupGetShieldResponse& from);
  void MergeFrom(const GroupGetShieldResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // repeated .Im.Base.ShieldStatus shield_status_list = 2;
  inline int shield_status_list_size() const;
  inline void clear_shield_status_list();
  static const int kShieldStatusListFieldNumber = 2;
  inline const ::Im::Base::ShieldStatus& shield_status_list(int index) const;
  inline ::Im::Base::ShieldStatus* mutable_shield_status_list(int index);
  inline ::Im::Base::ShieldStatus* add_shield_status_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Im::Base::ShieldStatus >&
      shield_status_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Im::Base::ShieldStatus >*
      mutable_shield_status_list();

  // optional bytes attach_data = 3;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 3;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:Im.Server.GroupGetShieldResponse)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Im::Base::ShieldStatus > shield_status_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 group_id_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static GroupGetShieldResponse* default_instance_;
};
// -------------------------------------------------------------------

class FileTransferRequest : public ::google::protobuf::Message {
 public:
  FileTransferRequest();
  virtual ~FileTransferRequest();

  FileTransferRequest(const FileTransferRequest& from);

  inline FileTransferRequest& operator=(const FileTransferRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileTransferRequest& default_instance();

  void Swap(FileTransferRequest* other);

  // implements Message ----------------------------------------------

  FileTransferRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileTransferRequest& from);
  void MergeFrom(const FileTransferRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from_user_id = 1;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 2;
  inline bool has_to_user_id() const;
  inline void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 to_user_id() const;
  inline void set_to_user_id(::google::protobuf::uint32 value);

  // required string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // required uint32 file_size = 4;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // required .Im.Base.FileType transfer_mode = 5;
  inline bool has_transfer_mode() const;
  inline void clear_transfer_mode();
  static const int kTransferModeFieldNumber = 5;
  inline ::Im::Base::FileType transfer_mode() const;
  inline void set_transfer_mode(::Im::Base::FileType value);

  // optional bytes attach_data = 6;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 6;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:Im.Server.FileTransferRequest)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_transfer_mode();
  inline void clear_has_transfer_mode();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::std::string* file_name_;
  ::google::protobuf::uint32 file_size_;
  int transfer_mode_;
  ::std::string* attach_data_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static FileTransferRequest* default_instance_;
};
// -------------------------------------------------------------------

class FileTransferResponse : public ::google::protobuf::Message {
 public:
  FileTransferResponse();
  virtual ~FileTransferResponse();

  FileTransferResponse(const FileTransferResponse& from);

  inline FileTransferResponse& operator=(const FileTransferResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileTransferResponse& default_instance();

  void Swap(FileTransferResponse* other);

  // implements Message ----------------------------------------------

  FileTransferResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileTransferResponse& from);
  void MergeFrom(const FileTransferResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result_code = 1;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // required uint32 from_user_id = 2;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 3;
  inline bool has_to_user_id() const;
  inline void clear_to_user_id();
  static const int kToUserIdFieldNumber = 3;
  inline ::google::protobuf::uint32 to_user_id() const;
  inline void set_to_user_id(::google::protobuf::uint32 value);

  // optional string file_name = 4;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 4;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // optional uint32 file_size = 5;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // optional string task_id = 6;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 6;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  inline void set_allocated_task_id(::std::string* task_id);

  // optional .Im.Base.FileType transfer_mode = 7;
  inline bool has_transfer_mode() const;
  inline void clear_transfer_mode();
  static const int kTransferModeFieldNumber = 7;
  inline ::Im::Base::FileType transfer_mode() const;
  inline void set_transfer_mode(::Im::Base::FileType value);

  // optional bytes attach_data = 8;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 8;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:Im.Server.FileTransferResponse)
 private:
  inline void set_has_result_code();
  inline void clear_has_result_code();
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_to_user_id();
  inline void clear_has_to_user_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_transfer_mode();
  inline void clear_has_transfer_mode();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::uint32 from_user_id_;
  ::std::string* file_name_;
  ::google::protobuf::uint32 to_user_id_;
  ::google::protobuf::uint32 file_size_;
  ::std::string* task_id_;
  ::std::string* attach_data_;
  int transfer_mode_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static FileTransferResponse* default_instance_;
};
// -------------------------------------------------------------------

class FileServerIpRequest : public ::google::protobuf::Message {
 public:
  FileServerIpRequest();
  virtual ~FileServerIpRequest();

  FileServerIpRequest(const FileServerIpRequest& from);

  inline FileServerIpRequest& operator=(const FileServerIpRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileServerIpRequest& default_instance();

  void Swap(FileServerIpRequest* other);

  // implements Message ----------------------------------------------

  FileServerIpRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileServerIpRequest& from);
  void MergeFrom(const FileServerIpRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Im.Server.FileServerIpRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static FileServerIpRequest* default_instance_;
};
// -------------------------------------------------------------------

class FileServerIpResponse : public ::google::protobuf::Message {
 public:
  FileServerIpResponse();
  virtual ~FileServerIpResponse();

  FileServerIpResponse(const FileServerIpResponse& from);

  inline FileServerIpResponse& operator=(const FileServerIpResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileServerIpResponse& default_instance();

  void Swap(FileServerIpResponse* other);

  // implements Message ----------------------------------------------

  FileServerIpResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileServerIpResponse& from);
  void MergeFrom(const FileServerIpResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Im.Base.IpAddr ip_addr_list = 1;
  inline int ip_addr_list_size() const;
  inline void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 1;
  inline const ::Im::Base::IpAddr& ip_addr_list(int index) const;
  inline ::Im::Base::IpAddr* mutable_ip_addr_list(int index);
  inline ::Im::Base::IpAddr* add_ip_addr_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Im::Base::IpAddr >&
      ip_addr_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Im::Base::IpAddr >*
      mutable_ip_addr_list();

  // @@protoc_insertion_point(class_scope:Im.Server.FileServerIpResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Im::Base::IpAddr > ip_addr_list_;
  friend void  protobuf_AddDesc_Im_2eServer_2eproto();
  friend void protobuf_AssignDesc_Im_2eServer_2eproto();
  friend void protobuf_ShutdownFile_Im_2eServer_2eproto();

  void InitAsDefaultInstance();
  static FileServerIpResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// ServerRequest

// -------------------------------------------------------------------

// ServerResponse

// required .Im.Base.ResultType result_type = 1;
inline bool ServerResponse::has_result_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerResponse::set_has_result_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerResponse::clear_has_result_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerResponse::clear_result_type() {
  result_type_ = 1;
  clear_has_result_type();
}
inline ::Im::Base::ResultType ServerResponse::result_type() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerResponse.result_type)
  return static_cast< ::Im::Base::ResultType >(result_type_);
}
inline void ServerResponse::set_result_type(::Im::Base::ResultType value) {
  assert(::Im::Base::ResultType_IsValid(value));
  set_has_result_type();
  result_type_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ServerResponse.result_type)
}

// optional string priority = 2;
inline bool ServerResponse::has_priority() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerResponse::set_has_priority() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerResponse::clear_has_priority() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerResponse::clear_priority() {
  if (priority_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    priority_->clear();
  }
  clear_has_priority();
}
inline const ::std::string& ServerResponse::priority() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerResponse.priority)
  return *priority_;
}
inline void ServerResponse::set_priority(const ::std::string& value) {
  set_has_priority();
  if (priority_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    priority_ = new ::std::string;
  }
  priority_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.ServerResponse.priority)
}
inline void ServerResponse::set_priority(const char* value) {
  set_has_priority();
  if (priority_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    priority_ = new ::std::string;
  }
  priority_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.ServerResponse.priority)
}
inline void ServerResponse::set_priority(const char* value, size_t size) {
  set_has_priority();
  if (priority_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    priority_ = new ::std::string;
  }
  priority_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.ServerResponse.priority)
}
inline ::std::string* ServerResponse::mutable_priority() {
  set_has_priority();
  if (priority_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    priority_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.ServerResponse.priority)
  return priority_;
}
inline ::std::string* ServerResponse::release_priority() {
  clear_has_priority();
  if (priority_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = priority_;
    priority_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerResponse::set_allocated_priority(::std::string* priority) {
  if (priority_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete priority_;
  }
  if (priority) {
    set_has_priority();
    priority_ = priority;
  } else {
    clear_has_priority();
    priority_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.ServerResponse.priority)
}

// optional string backup = 3;
inline bool ServerResponse::has_backup() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerResponse::set_has_backup() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerResponse::clear_has_backup() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerResponse::clear_backup() {
  if (backup_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backup_->clear();
  }
  clear_has_backup();
}
inline const ::std::string& ServerResponse::backup() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerResponse.backup)
  return *backup_;
}
inline void ServerResponse::set_backup(const ::std::string& value) {
  set_has_backup();
  if (backup_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backup_ = new ::std::string;
  }
  backup_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.ServerResponse.backup)
}
inline void ServerResponse::set_backup(const char* value) {
  set_has_backup();
  if (backup_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backup_ = new ::std::string;
  }
  backup_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.ServerResponse.backup)
}
inline void ServerResponse::set_backup(const char* value, size_t size) {
  set_has_backup();
  if (backup_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backup_ = new ::std::string;
  }
  backup_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.ServerResponse.backup)
}
inline ::std::string* ServerResponse::mutable_backup() {
  set_has_backup();
  if (backup_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    backup_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.ServerResponse.backup)
  return backup_;
}
inline ::std::string* ServerResponse::release_backup() {
  clear_has_backup();
  if (backup_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = backup_;
    backup_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerResponse::set_allocated_backup(::std::string* backup) {
  if (backup_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete backup_;
  }
  if (backup) {
    set_has_backup();
    backup_ = backup;
  } else {
    clear_has_backup();
    backup_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.ServerResponse.backup)
}

// optional uint32 port = 4;
inline bool ServerResponse::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerResponse::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerResponse::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerResponse::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ServerResponse::port() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerResponse.port)
  return port_;
}
inline void ServerResponse::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ServerResponse.port)
}

// -------------------------------------------------------------------

// StopReceivePacket

// required uint32 result = 1;
inline bool StopReceivePacket::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopReceivePacket::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopReceivePacket::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopReceivePacket::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 StopReceivePacket::result() const {
  // @@protoc_insertion_point(field_get:Im.Server.StopReceivePacket.result)
  return result_;
}
inline void StopReceivePacket::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.StopReceivePacket.result)
}

// -------------------------------------------------------------------

// ValidateRequest

// required string user_name = 1;
inline bool ValidateRequest::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ValidateRequest::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ValidateRequest::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ValidateRequest::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& ValidateRequest::user_name() const {
  // @@protoc_insertion_point(field_get:Im.Server.ValidateRequest.user_name)
  return *user_name_;
}
inline void ValidateRequest::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.ValidateRequest.user_name)
}
inline void ValidateRequest::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.ValidateRequest.user_name)
}
inline void ValidateRequest::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.ValidateRequest.user_name)
}
inline ::std::string* ValidateRequest::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.ValidateRequest.user_name)
  return user_name_;
}
inline ::std::string* ValidateRequest::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ValidateRequest::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.ValidateRequest.user_name)
}

// required string user_password = 2;
inline bool ValidateRequest::has_user_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ValidateRequest::set_has_user_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ValidateRequest::clear_has_user_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ValidateRequest::clear_user_password() {
  if (user_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_password_->clear();
  }
  clear_has_user_password();
}
inline const ::std::string& ValidateRequest::user_password() const {
  // @@protoc_insertion_point(field_get:Im.Server.ValidateRequest.user_password)
  return *user_password_;
}
inline void ValidateRequest::set_user_password(const ::std::string& value) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.ValidateRequest.user_password)
}
inline void ValidateRequest::set_user_password(const char* value) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.ValidateRequest.user_password)
}
inline void ValidateRequest::set_user_password(const char* value, size_t size) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.ValidateRequest.user_password)
}
inline ::std::string* ValidateRequest::mutable_user_password() {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.ValidateRequest.user_password)
  return user_password_;
}
inline ::std::string* ValidateRequest::release_user_password() {
  clear_has_user_password();
  if (user_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_password_;
    user_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ValidateRequest::set_allocated_user_password(::std::string* user_password) {
  if (user_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_password_;
  }
  if (user_password) {
    set_has_user_password();
    user_password_ = user_password;
  } else {
    clear_has_user_password();
    user_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.ValidateRequest.user_password)
}

// optional bytes attach_data = 3;
inline bool ValidateRequest::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ValidateRequest::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ValidateRequest::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ValidateRequest::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& ValidateRequest::attach_data() const {
  // @@protoc_insertion_point(field_get:Im.Server.ValidateRequest.attach_data)
  return *attach_data_;
}
inline void ValidateRequest::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.ValidateRequest.attach_data)
}
inline void ValidateRequest::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.ValidateRequest.attach_data)
}
inline void ValidateRequest::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.ValidateRequest.attach_data)
}
inline ::std::string* ValidateRequest::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.ValidateRequest.attach_data)
  return attach_data_;
}
inline ::std::string* ValidateRequest::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ValidateRequest::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.ValidateRequest.attach_data)
}

// -------------------------------------------------------------------

// ValidateResponse

// required string user_name = 1;
inline bool ValidateResponse::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ValidateResponse::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ValidateResponse::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ValidateResponse::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& ValidateResponse::user_name() const {
  // @@protoc_insertion_point(field_get:Im.Server.ValidateResponse.user_name)
  return *user_name_;
}
inline void ValidateResponse::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.ValidateResponse.user_name)
}
inline void ValidateResponse::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.ValidateResponse.user_name)
}
inline void ValidateResponse::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.ValidateResponse.user_name)
}
inline ::std::string* ValidateResponse::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.ValidateResponse.user_name)
  return user_name_;
}
inline ::std::string* ValidateResponse::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ValidateResponse::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.ValidateResponse.user_name)
}

// required uint32 result_code = 2;
inline bool ValidateResponse::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ValidateResponse::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ValidateResponse::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ValidateResponse::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 ValidateResponse::result_code() const {
  // @@protoc_insertion_point(field_get:Im.Server.ValidateResponse.result_code)
  return result_code_;
}
inline void ValidateResponse::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ValidateResponse.result_code)
}

// optional string result_string = 3;
inline bool ValidateResponse::has_result_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ValidateResponse::set_has_result_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ValidateResponse::clear_has_result_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ValidateResponse::clear_result_string() {
  if (result_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_string_->clear();
  }
  clear_has_result_string();
}
inline const ::std::string& ValidateResponse::result_string() const {
  // @@protoc_insertion_point(field_get:Im.Server.ValidateResponse.result_string)
  return *result_string_;
}
inline void ValidateResponse::set_result_string(const ::std::string& value) {
  set_has_result_string();
  if (result_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_string_ = new ::std::string;
  }
  result_string_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.ValidateResponse.result_string)
}
inline void ValidateResponse::set_result_string(const char* value) {
  set_has_result_string();
  if (result_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_string_ = new ::std::string;
  }
  result_string_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.ValidateResponse.result_string)
}
inline void ValidateResponse::set_result_string(const char* value, size_t size) {
  set_has_result_string();
  if (result_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_string_ = new ::std::string;
  }
  result_string_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.ValidateResponse.result_string)
}
inline ::std::string* ValidateResponse::mutable_result_string() {
  set_has_result_string();
  if (result_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_string_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.ValidateResponse.result_string)
  return result_string_;
}
inline ::std::string* ValidateResponse::release_result_string() {
  clear_has_result_string();
  if (result_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_string_;
    result_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ValidateResponse::set_allocated_result_string(::std::string* result_string) {
  if (result_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_string_;
  }
  if (result_string) {
    set_has_result_string();
    result_string_ = result_string;
  } else {
    clear_has_result_string();
    result_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.ValidateResponse.result_string)
}

// optional .Im.Base.UserInfo user_info = 4;
inline bool ValidateResponse::has_user_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ValidateResponse::set_has_user_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ValidateResponse::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ValidateResponse::clear_user_info() {
  if (user_info_ != NULL) user_info_->::Im::Base::UserInfo::Clear();
  clear_has_user_info();
}
inline const ::Im::Base::UserInfo& ValidateResponse::user_info() const {
  // @@protoc_insertion_point(field_get:Im.Server.ValidateResponse.user_info)
  return user_info_ != NULL ? *user_info_ : *default_instance_->user_info_;
}
inline ::Im::Base::UserInfo* ValidateResponse::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) user_info_ = new ::Im::Base::UserInfo;
  // @@protoc_insertion_point(field_mutable:Im.Server.ValidateResponse.user_info)
  return user_info_;
}
inline ::Im::Base::UserInfo* ValidateResponse::release_user_info() {
  clear_has_user_info();
  ::Im::Base::UserInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void ValidateResponse::set_allocated_user_info(::Im::Base::UserInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.ValidateResponse.user_info)
}

// optional bytes attach_data = 5;
inline bool ValidateResponse::has_attach_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ValidateResponse::set_has_attach_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ValidateResponse::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ValidateResponse::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& ValidateResponse::attach_data() const {
  // @@protoc_insertion_point(field_get:Im.Server.ValidateResponse.attach_data)
  return *attach_data_;
}
inline void ValidateResponse::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.ValidateResponse.attach_data)
}
inline void ValidateResponse::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.ValidateResponse.attach_data)
}
inline void ValidateResponse::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.ValidateResponse.attach_data)
}
inline ::std::string* ValidateResponse::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.ValidateResponse.attach_data)
  return attach_data_;
}
inline ::std::string* ValidateResponse::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ValidateResponse::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.ValidateResponse.attach_data)
}

// -------------------------------------------------------------------

// GetDeviceTokenRequest

// repeated uint32 user_id = 1;
inline int GetDeviceTokenRequest::user_id_size() const {
  return user_id_.size();
}
inline void GetDeviceTokenRequest::clear_user_id() {
  user_id_.Clear();
}
inline ::google::protobuf::uint32 GetDeviceTokenRequest::user_id(int index) const {
  // @@protoc_insertion_point(field_get:Im.Server.GetDeviceTokenRequest.user_id)
  return user_id_.Get(index);
}
inline void GetDeviceTokenRequest::set_user_id(int index, ::google::protobuf::uint32 value) {
  user_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:Im.Server.GetDeviceTokenRequest.user_id)
}
inline void GetDeviceTokenRequest::add_user_id(::google::protobuf::uint32 value) {
  user_id_.Add(value);
  // @@protoc_insertion_point(field_add:Im.Server.GetDeviceTokenRequest.user_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetDeviceTokenRequest::user_id() const {
  // @@protoc_insertion_point(field_list:Im.Server.GetDeviceTokenRequest.user_id)
  return user_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetDeviceTokenRequest::mutable_user_id() {
  // @@protoc_insertion_point(field_mutable_list:Im.Server.GetDeviceTokenRequest.user_id)
  return &user_id_;
}

// optional bytes attach_data = 2;
inline bool GetDeviceTokenRequest::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDeviceTokenRequest::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDeviceTokenRequest::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDeviceTokenRequest::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& GetDeviceTokenRequest::attach_data() const {
  // @@protoc_insertion_point(field_get:Im.Server.GetDeviceTokenRequest.attach_data)
  return *attach_data_;
}
inline void GetDeviceTokenRequest::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.GetDeviceTokenRequest.attach_data)
}
inline void GetDeviceTokenRequest::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.GetDeviceTokenRequest.attach_data)
}
inline void GetDeviceTokenRequest::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.GetDeviceTokenRequest.attach_data)
}
inline ::std::string* GetDeviceTokenRequest::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.GetDeviceTokenRequest.attach_data)
  return attach_data_;
}
inline ::std::string* GetDeviceTokenRequest::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetDeviceTokenRequest::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.GetDeviceTokenRequest.attach_data)
}

// -------------------------------------------------------------------

// GetDeviceTokenResponse

// repeated .Im.Base.UserTokenInfo user_token_info = 1;
inline int GetDeviceTokenResponse::user_token_info_size() const {
  return user_token_info_.size();
}
inline void GetDeviceTokenResponse::clear_user_token_info() {
  user_token_info_.Clear();
}
inline const ::Im::Base::UserTokenInfo& GetDeviceTokenResponse::user_token_info(int index) const {
  // @@protoc_insertion_point(field_get:Im.Server.GetDeviceTokenResponse.user_token_info)
  return user_token_info_.Get(index);
}
inline ::Im::Base::UserTokenInfo* GetDeviceTokenResponse::mutable_user_token_info(int index) {
  // @@protoc_insertion_point(field_mutable:Im.Server.GetDeviceTokenResponse.user_token_info)
  return user_token_info_.Mutable(index);
}
inline ::Im::Base::UserTokenInfo* GetDeviceTokenResponse::add_user_token_info() {
  // @@protoc_insertion_point(field_add:Im.Server.GetDeviceTokenResponse.user_token_info)
  return user_token_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Im::Base::UserTokenInfo >&
GetDeviceTokenResponse::user_token_info() const {
  // @@protoc_insertion_point(field_list:Im.Server.GetDeviceTokenResponse.user_token_info)
  return user_token_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::Im::Base::UserTokenInfo >*
GetDeviceTokenResponse::mutable_user_token_info() {
  // @@protoc_insertion_point(field_mutable_list:Im.Server.GetDeviceTokenResponse.user_token_info)
  return &user_token_info_;
}

// optional bytes attach_data = 2;
inline bool GetDeviceTokenResponse::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetDeviceTokenResponse::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetDeviceTokenResponse::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetDeviceTokenResponse::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& GetDeviceTokenResponse::attach_data() const {
  // @@protoc_insertion_point(field_get:Im.Server.GetDeviceTokenResponse.attach_data)
  return *attach_data_;
}
inline void GetDeviceTokenResponse::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.GetDeviceTokenResponse.attach_data)
}
inline void GetDeviceTokenResponse::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.GetDeviceTokenResponse.attach_data)
}
inline void GetDeviceTokenResponse::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.GetDeviceTokenResponse.attach_data)
}
inline ::std::string* GetDeviceTokenResponse::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.GetDeviceTokenResponse.attach_data)
  return attach_data_;
}
inline ::std::string* GetDeviceTokenResponse::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetDeviceTokenResponse::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.GetDeviceTokenResponse.attach_data)
}

// -------------------------------------------------------------------

// RoleSet

// required uint32 master_id = 1;
inline bool RoleSet::has_master_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleSet::set_has_master_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleSet::clear_has_master_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleSet::clear_master_id() {
  master_id_ = 0u;
  clear_has_master_id();
}
inline ::google::protobuf::uint32 RoleSet::master_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.RoleSet.master_id)
  return master_id_;
}
inline void RoleSet::set_master_id(::google::protobuf::uint32 value) {
  set_has_master_id();
  master_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.RoleSet.master_id)
}

// -------------------------------------------------------------------

// OnlineUserInfo

// repeated .Im.Base.ServerUserStatus user_status_list = 1;
inline int OnlineUserInfo::user_status_list_size() const {
  return user_status_list_.size();
}
inline void OnlineUserInfo::clear_user_status_list() {
  user_status_list_.Clear();
}
inline const ::Im::Base::ServerUserStatus& OnlineUserInfo::user_status_list(int index) const {
  // @@protoc_insertion_point(field_get:Im.Server.OnlineUserInfo.user_status_list)
  return user_status_list_.Get(index);
}
inline ::Im::Base::ServerUserStatus* OnlineUserInfo::mutable_user_status_list(int index) {
  // @@protoc_insertion_point(field_mutable:Im.Server.OnlineUserInfo.user_status_list)
  return user_status_list_.Mutable(index);
}
inline ::Im::Base::ServerUserStatus* OnlineUserInfo::add_user_status_list() {
  // @@protoc_insertion_point(field_add:Im.Server.OnlineUserInfo.user_status_list)
  return user_status_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Im::Base::ServerUserStatus >&
OnlineUserInfo::user_status_list() const {
  // @@protoc_insertion_point(field_list:Im.Server.OnlineUserInfo.user_status_list)
  return user_status_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Im::Base::ServerUserStatus >*
OnlineUserInfo::mutable_user_status_list() {
  // @@protoc_insertion_point(field_mutable_list:Im.Server.OnlineUserInfo.user_status_list)
  return &user_status_list_;
}

// -------------------------------------------------------------------

// MsgServerInfo

// required string ip_1 = 1;
inline bool MsgServerInfo::has_ip_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgServerInfo::set_has_ip_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgServerInfo::clear_has_ip_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgServerInfo::clear_ip_1() {
  if (ip_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_1_->clear();
  }
  clear_has_ip_1();
}
inline const ::std::string& MsgServerInfo::ip_1() const {
  // @@protoc_insertion_point(field_get:Im.Server.MsgServerInfo.ip_1)
  return *ip_1_;
}
inline void MsgServerInfo::set_ip_1(const ::std::string& value) {
  set_has_ip_1();
  if (ip_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_1_ = new ::std::string;
  }
  ip_1_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.MsgServerInfo.ip_1)
}
inline void MsgServerInfo::set_ip_1(const char* value) {
  set_has_ip_1();
  if (ip_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_1_ = new ::std::string;
  }
  ip_1_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.MsgServerInfo.ip_1)
}
inline void MsgServerInfo::set_ip_1(const char* value, size_t size) {
  set_has_ip_1();
  if (ip_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_1_ = new ::std::string;
  }
  ip_1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.MsgServerInfo.ip_1)
}
inline ::std::string* MsgServerInfo::mutable_ip_1() {
  set_has_ip_1();
  if (ip_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.MsgServerInfo.ip_1)
  return ip_1_;
}
inline ::std::string* MsgServerInfo::release_ip_1() {
  clear_has_ip_1();
  if (ip_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_1_;
    ip_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgServerInfo::set_allocated_ip_1(::std::string* ip_1) {
  if (ip_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_1_;
  }
  if (ip_1) {
    set_has_ip_1();
    ip_1_ = ip_1;
  } else {
    clear_has_ip_1();
    ip_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.MsgServerInfo.ip_1)
}

// required string ip_2 = 2;
inline bool MsgServerInfo::has_ip_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgServerInfo::set_has_ip_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgServerInfo::clear_has_ip_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgServerInfo::clear_ip_2() {
  if (ip_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_2_->clear();
  }
  clear_has_ip_2();
}
inline const ::std::string& MsgServerInfo::ip_2() const {
  // @@protoc_insertion_point(field_get:Im.Server.MsgServerInfo.ip_2)
  return *ip_2_;
}
inline void MsgServerInfo::set_ip_2(const ::std::string& value) {
  set_has_ip_2();
  if (ip_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_2_ = new ::std::string;
  }
  ip_2_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.MsgServerInfo.ip_2)
}
inline void MsgServerInfo::set_ip_2(const char* value) {
  set_has_ip_2();
  if (ip_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_2_ = new ::std::string;
  }
  ip_2_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.MsgServerInfo.ip_2)
}
inline void MsgServerInfo::set_ip_2(const char* value, size_t size) {
  set_has_ip_2();
  if (ip_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_2_ = new ::std::string;
  }
  ip_2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.MsgServerInfo.ip_2)
}
inline ::std::string* MsgServerInfo::mutable_ip_2() {
  set_has_ip_2();
  if (ip_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.MsgServerInfo.ip_2)
  return ip_2_;
}
inline ::std::string* MsgServerInfo::release_ip_2() {
  clear_has_ip_2();
  if (ip_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_2_;
    ip_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgServerInfo::set_allocated_ip_2(::std::string* ip_2) {
  if (ip_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_2_;
  }
  if (ip_2) {
    set_has_ip_2();
    ip_2_ = ip_2;
  } else {
    clear_has_ip_2();
    ip_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.MsgServerInfo.ip_2)
}

// required uint32 port = 3;
inline bool MsgServerInfo::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgServerInfo::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgServerInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgServerInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 MsgServerInfo::port() const {
  // @@protoc_insertion_point(field_get:Im.Server.MsgServerInfo.port)
  return port_;
}
inline void MsgServerInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.MsgServerInfo.port)
}

// required string host_name = 4;
inline bool MsgServerInfo::has_host_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgServerInfo::set_has_host_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgServerInfo::clear_has_host_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgServerInfo::clear_host_name() {
  if (host_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_->clear();
  }
  clear_has_host_name();
}
inline const ::std::string& MsgServerInfo::host_name() const {
  // @@protoc_insertion_point(field_get:Im.Server.MsgServerInfo.host_name)
  return *host_name_;
}
inline void MsgServerInfo::set_host_name(const ::std::string& value) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.MsgServerInfo.host_name)
}
inline void MsgServerInfo::set_host_name(const char* value) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.MsgServerInfo.host_name)
}
inline void MsgServerInfo::set_host_name(const char* value, size_t size) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.MsgServerInfo.host_name)
}
inline ::std::string* MsgServerInfo::mutable_host_name() {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.MsgServerInfo.host_name)
  return host_name_;
}
inline ::std::string* MsgServerInfo::release_host_name() {
  clear_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = host_name_;
    host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgServerInfo::set_allocated_host_name(::std::string* host_name) {
  if (host_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_name_;
  }
  if (host_name) {
    set_has_host_name();
    host_name_ = host_name;
  } else {
    clear_has_host_name();
    host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.MsgServerInfo.host_name)
}

// required uint32 max_connect_cnt = 5;
inline bool MsgServerInfo::has_max_connect_cnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgServerInfo::set_has_max_connect_cnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgServerInfo::clear_has_max_connect_cnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgServerInfo::clear_max_connect_cnt() {
  max_connect_cnt_ = 0u;
  clear_has_max_connect_cnt();
}
inline ::google::protobuf::uint32 MsgServerInfo::max_connect_cnt() const {
  // @@protoc_insertion_point(field_get:Im.Server.MsgServerInfo.max_connect_cnt)
  return max_connect_cnt_;
}
inline void MsgServerInfo::set_max_connect_cnt(::google::protobuf::uint32 value) {
  set_has_max_connect_cnt();
  max_connect_cnt_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.MsgServerInfo.max_connect_cnt)
}

// required uint32 current_connect_cnt = 6;
inline bool MsgServerInfo::has_current_connect_cnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgServerInfo::set_has_current_connect_cnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgServerInfo::clear_has_current_connect_cnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgServerInfo::clear_current_connect_cnt() {
  current_connect_cnt_ = 0u;
  clear_has_current_connect_cnt();
}
inline ::google::protobuf::uint32 MsgServerInfo::current_connect_cnt() const {
  // @@protoc_insertion_point(field_get:Im.Server.MsgServerInfo.current_connect_cnt)
  return current_connect_cnt_;
}
inline void MsgServerInfo::set_current_connect_cnt(::google::protobuf::uint32 value) {
  set_has_current_connect_cnt();
  current_connect_cnt_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.MsgServerInfo.current_connect_cnt)
}

// -------------------------------------------------------------------

// ServerInfo

// required string ip_1 = 1;
inline bool ServerInfo::has_ip_1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfo::set_has_ip_1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfo::clear_has_ip_1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfo::clear_ip_1() {
  if (ip_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_1_->clear();
  }
  clear_has_ip_1();
}
inline const ::std::string& ServerInfo::ip_1() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerInfo.ip_1)
  return *ip_1_;
}
inline void ServerInfo::set_ip_1(const ::std::string& value) {
  set_has_ip_1();
  if (ip_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_1_ = new ::std::string;
  }
  ip_1_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.ServerInfo.ip_1)
}
inline void ServerInfo::set_ip_1(const char* value) {
  set_has_ip_1();
  if (ip_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_1_ = new ::std::string;
  }
  ip_1_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.ServerInfo.ip_1)
}
inline void ServerInfo::set_ip_1(const char* value, size_t size) {
  set_has_ip_1();
  if (ip_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_1_ = new ::std::string;
  }
  ip_1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.ServerInfo.ip_1)
}
inline ::std::string* ServerInfo::mutable_ip_1() {
  set_has_ip_1();
  if (ip_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.ServerInfo.ip_1)
  return ip_1_;
}
inline ::std::string* ServerInfo::release_ip_1() {
  clear_has_ip_1();
  if (ip_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_1_;
    ip_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerInfo::set_allocated_ip_1(::std::string* ip_1) {
  if (ip_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_1_;
  }
  if (ip_1) {
    set_has_ip_1();
    ip_1_ = ip_1;
  } else {
    clear_has_ip_1();
    ip_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.ServerInfo.ip_1)
}

// required string ip_2 = 2;
inline bool ServerInfo::has_ip_2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerInfo::set_has_ip_2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerInfo::clear_has_ip_2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerInfo::clear_ip_2() {
  if (ip_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_2_->clear();
  }
  clear_has_ip_2();
}
inline const ::std::string& ServerInfo::ip_2() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerInfo.ip_2)
  return *ip_2_;
}
inline void ServerInfo::set_ip_2(const ::std::string& value) {
  set_has_ip_2();
  if (ip_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_2_ = new ::std::string;
  }
  ip_2_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.ServerInfo.ip_2)
}
inline void ServerInfo::set_ip_2(const char* value) {
  set_has_ip_2();
  if (ip_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_2_ = new ::std::string;
  }
  ip_2_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.ServerInfo.ip_2)
}
inline void ServerInfo::set_ip_2(const char* value, size_t size) {
  set_has_ip_2();
  if (ip_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_2_ = new ::std::string;
  }
  ip_2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.ServerInfo.ip_2)
}
inline ::std::string* ServerInfo::mutable_ip_2() {
  set_has_ip_2();
  if (ip_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.ServerInfo.ip_2)
  return ip_2_;
}
inline ::std::string* ServerInfo::release_ip_2() {
  clear_has_ip_2();
  if (ip_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_2_;
    ip_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerInfo::set_allocated_ip_2(::std::string* ip_2) {
  if (ip_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_2_;
  }
  if (ip_2) {
    set_has_ip_2();
    ip_2_ = ip_2;
  } else {
    clear_has_ip_2();
    ip_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.ServerInfo.ip_2)
}

// required uint32 port = 3;
inline bool ServerInfo::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerInfo::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ServerInfo::port() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerInfo.port)
  return port_;
}
inline void ServerInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ServerInfo.port)
}

// required string host_name = 4;
inline bool ServerInfo::has_host_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerInfo::set_has_host_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerInfo::clear_has_host_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerInfo::clear_host_name() {
  if (host_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_->clear();
  }
  clear_has_host_name();
}
inline const ::std::string& ServerInfo::host_name() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerInfo.host_name)
  return *host_name_;
}
inline void ServerInfo::set_host_name(const ::std::string& value) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.ServerInfo.host_name)
}
inline void ServerInfo::set_host_name(const char* value) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.ServerInfo.host_name)
}
inline void ServerInfo::set_host_name(const char* value, size_t size) {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_ = new ::std::string;
  }
  host_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.ServerInfo.host_name)
}
inline ::std::string* ServerInfo::mutable_host_name() {
  set_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    host_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.ServerInfo.host_name)
  return host_name_;
}
inline ::std::string* ServerInfo::release_host_name() {
  clear_has_host_name();
  if (host_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = host_name_;
    host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerInfo::set_allocated_host_name(::std::string* host_name) {
  if (host_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete host_name_;
  }
  if (host_name) {
    set_has_host_name();
    host_name_ = host_name;
  } else {
    clear_has_host_name();
    host_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.ServerInfo.host_name)
}

// required uint32 max_connect_cnt = 5;
inline bool ServerInfo::has_max_connect_cnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerInfo::set_has_max_connect_cnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerInfo::clear_has_max_connect_cnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerInfo::clear_max_connect_cnt() {
  max_connect_cnt_ = 0u;
  clear_has_max_connect_cnt();
}
inline ::google::protobuf::uint32 ServerInfo::max_connect_cnt() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerInfo.max_connect_cnt)
  return max_connect_cnt_;
}
inline void ServerInfo::set_max_connect_cnt(::google::protobuf::uint32 value) {
  set_has_max_connect_cnt();
  max_connect_cnt_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ServerInfo.max_connect_cnt)
}

// required uint32 cur_connect_cnt = 6;
inline bool ServerInfo::has_cur_connect_cnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerInfo::set_has_cur_connect_cnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerInfo::clear_has_cur_connect_cnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerInfo::clear_cur_connect_cnt() {
  cur_connect_cnt_ = 0u;
  clear_has_cur_connect_cnt();
}
inline ::google::protobuf::uint32 ServerInfo::cur_connect_cnt() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerInfo.cur_connect_cnt)
  return cur_connect_cnt_;
}
inline void ServerInfo::set_cur_connect_cnt(::google::protobuf::uint32 value) {
  set_has_cur_connect_cnt();
  cur_connect_cnt_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ServerInfo.cur_connect_cnt)
}

// -------------------------------------------------------------------

// UserStatusUpdate

// required uint32 user_status = 1;
inline bool UserStatusUpdate::has_user_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStatusUpdate::set_has_user_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStatusUpdate::clear_has_user_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStatusUpdate::clear_user_status() {
  user_status_ = 0u;
  clear_has_user_status();
}
inline ::google::protobuf::uint32 UserStatusUpdate::user_status() const {
  // @@protoc_insertion_point(field_get:Im.Server.UserStatusUpdate.user_status)
  return user_status_;
}
inline void UserStatusUpdate::set_user_status(::google::protobuf::uint32 value) {
  set_has_user_status();
  user_status_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.UserStatusUpdate.user_status)
}

// required uint32 user_id = 2;
inline bool UserStatusUpdate::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStatusUpdate::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStatusUpdate::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStatusUpdate::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserStatusUpdate::user_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.UserStatusUpdate.user_id)
  return user_id_;
}
inline void UserStatusUpdate::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.UserStatusUpdate.user_id)
}

// required .Im.Base.ClientType client_type = 3;
inline bool UserStatusUpdate::has_client_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStatusUpdate::set_has_client_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserStatusUpdate::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserStatusUpdate::clear_client_type() {
  client_type_ = 1;
  clear_has_client_type();
}
inline ::Im::Base::ClientType UserStatusUpdate::client_type() const {
  // @@protoc_insertion_point(field_get:Im.Server.UserStatusUpdate.client_type)
  return static_cast< ::Im::Base::ClientType >(client_type_);
}
inline void UserStatusUpdate::set_client_type(::Im::Base::ClientType value) {
  assert(::Im::Base::ClientType_IsValid(value));
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.UserStatusUpdate.client_type)
}

// -------------------------------------------------------------------

// UserCountUpdate

// required uint32 user_action = 1;
inline bool UserCountUpdate::has_user_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserCountUpdate::set_has_user_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserCountUpdate::clear_has_user_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserCountUpdate::clear_user_action() {
  user_action_ = 0u;
  clear_has_user_action();
}
inline ::google::protobuf::uint32 UserCountUpdate::user_action() const {
  // @@protoc_insertion_point(field_get:Im.Server.UserCountUpdate.user_action)
  return user_action_;
}
inline void UserCountUpdate::set_user_action(::google::protobuf::uint32 value) {
  set_has_user_action();
  user_action_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.UserCountUpdate.user_action)
}

// required uint32 user_id = 2;
inline bool UserCountUpdate::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserCountUpdate::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserCountUpdate::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserCountUpdate::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserCountUpdate::user_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.UserCountUpdate.user_id)
  return user_id_;
}
inline void UserCountUpdate::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.UserCountUpdate.user_id)
}

// -------------------------------------------------------------------

// ServerUpdateNotity

// required uint32 action = 1;
inline bool ServerUpdateNotity::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerUpdateNotity::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerUpdateNotity::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerUpdateNotity::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 ServerUpdateNotity::action() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerUpdateNotity.action)
  return action_;
}
inline void ServerUpdateNotity::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ServerUpdateNotity.action)
}

// required uint32 user_id = 2;
inline bool ServerUpdateNotity::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerUpdateNotity::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerUpdateNotity::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerUpdateNotity::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 ServerUpdateNotity::user_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerUpdateNotity.user_id)
  return user_id_;
}
inline void ServerUpdateNotity::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ServerUpdateNotity.user_id)
}

// -------------------------------------------------------------------

// ServerKickUser

// required uint32 user_id = 1;
inline bool ServerKickUser::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerKickUser::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerKickUser::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerKickUser::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 ServerKickUser::user_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerKickUser.user_id)
  return user_id_;
}
inline void ServerKickUser::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ServerKickUser.user_id)
}

// required .Im.Base.ClientType client_type = 2;
inline bool ServerKickUser::has_client_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerKickUser::set_has_client_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerKickUser::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerKickUser::clear_client_type() {
  client_type_ = 1;
  clear_has_client_type();
}
inline ::Im::Base::ClientType ServerKickUser::client_type() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerKickUser.client_type)
  return static_cast< ::Im::Base::ClientType >(client_type_);
}
inline void ServerKickUser::set_client_type(::Im::Base::ClientType value) {
  assert(::Im::Base::ClientType_IsValid(value));
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ServerKickUser.client_type)
}

// required uint32 reason = 3;
inline bool ServerKickUser::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerKickUser::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerKickUser::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerKickUser::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 ServerKickUser::reason() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerKickUser.reason)
  return reason_;
}
inline void ServerKickUser::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ServerKickUser.reason)
}

// -------------------------------------------------------------------

// ServerPcLoginStatusNotify

// required uint32 user_id = 1;
inline bool ServerPcLoginStatusNotify::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerPcLoginStatusNotify::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerPcLoginStatusNotify::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerPcLoginStatusNotify::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 ServerPcLoginStatusNotify::user_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerPcLoginStatusNotify.user_id)
  return user_id_;
}
inline void ServerPcLoginStatusNotify::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ServerPcLoginStatusNotify.user_id)
}

// required uint32 login_status = 2;
inline bool ServerPcLoginStatusNotify::has_login_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerPcLoginStatusNotify::set_has_login_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerPcLoginStatusNotify::clear_has_login_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerPcLoginStatusNotify::clear_login_status() {
  login_status_ = 0u;
  clear_has_login_status();
}
inline ::google::protobuf::uint32 ServerPcLoginStatusNotify::login_status() const {
  // @@protoc_insertion_point(field_get:Im.Server.ServerPcLoginStatusNotify.login_status)
  return login_status_;
}
inline void ServerPcLoginStatusNotify::set_login_status(::google::protobuf::uint32 value) {
  set_has_login_status();
  login_status_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.ServerPcLoginStatusNotify.login_status)
}

// -------------------------------------------------------------------

// PushToUserRequest

// required string flash = 1;
inline bool PushToUserRequest::has_flash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushToUserRequest::set_has_flash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushToUserRequest::clear_has_flash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushToUserRequest::clear_flash() {
  if (flash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    flash_->clear();
  }
  clear_has_flash();
}
inline const ::std::string& PushToUserRequest::flash() const {
  // @@protoc_insertion_point(field_get:Im.Server.PushToUserRequest.flash)
  return *flash_;
}
inline void PushToUserRequest::set_flash(const ::std::string& value) {
  set_has_flash();
  if (flash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    flash_ = new ::std::string;
  }
  flash_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.PushToUserRequest.flash)
}
inline void PushToUserRequest::set_flash(const char* value) {
  set_has_flash();
  if (flash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    flash_ = new ::std::string;
  }
  flash_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.PushToUserRequest.flash)
}
inline void PushToUserRequest::set_flash(const char* value, size_t size) {
  set_has_flash();
  if (flash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    flash_ = new ::std::string;
  }
  flash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.PushToUserRequest.flash)
}
inline ::std::string* PushToUserRequest::mutable_flash() {
  set_has_flash();
  if (flash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    flash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.PushToUserRequest.flash)
  return flash_;
}
inline ::std::string* PushToUserRequest::release_flash() {
  clear_has_flash();
  if (flash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = flash_;
    flash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushToUserRequest::set_allocated_flash(::std::string* flash) {
  if (flash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete flash_;
  }
  if (flash) {
    set_has_flash();
    flash_ = flash;
  } else {
    clear_has_flash();
    flash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.PushToUserRequest.flash)
}

// required string data = 2;
inline bool PushToUserRequest::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushToUserRequest::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushToUserRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushToUserRequest::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PushToUserRequest::data() const {
  // @@protoc_insertion_point(field_get:Im.Server.PushToUserRequest.data)
  return *data_;
}
inline void PushToUserRequest::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.PushToUserRequest.data)
}
inline void PushToUserRequest::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.PushToUserRequest.data)
}
inline void PushToUserRequest::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.PushToUserRequest.data)
}
inline ::std::string* PushToUserRequest::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.PushToUserRequest.data)
  return data_;
}
inline ::std::string* PushToUserRequest::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushToUserRequest::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.PushToUserRequest.data)
}

// repeated .Im.Base.UserTokenInfo user_token_list = 3;
inline int PushToUserRequest::user_token_list_size() const {
  return user_token_list_.size();
}
inline void PushToUserRequest::clear_user_token_list() {
  user_token_list_.Clear();
}
inline const ::Im::Base::UserTokenInfo& PushToUserRequest::user_token_list(int index) const {
  // @@protoc_insertion_point(field_get:Im.Server.PushToUserRequest.user_token_list)
  return user_token_list_.Get(index);
}
inline ::Im::Base::UserTokenInfo* PushToUserRequest::mutable_user_token_list(int index) {
  // @@protoc_insertion_point(field_mutable:Im.Server.PushToUserRequest.user_token_list)
  return user_token_list_.Mutable(index);
}
inline ::Im::Base::UserTokenInfo* PushToUserRequest::add_user_token_list() {
  // @@protoc_insertion_point(field_add:Im.Server.PushToUserRequest.user_token_list)
  return user_token_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Im::Base::UserTokenInfo >&
PushToUserRequest::user_token_list() const {
  // @@protoc_insertion_point(field_list:Im.Server.PushToUserRequest.user_token_list)
  return user_token_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Im::Base::UserTokenInfo >*
PushToUserRequest::mutable_user_token_list() {
  // @@protoc_insertion_point(field_mutable_list:Im.Server.PushToUserRequest.user_token_list)
  return &user_token_list_;
}

// -------------------------------------------------------------------

// PushToUserRepsonse

// repeated .Im.Base.PushResult push_result_list = 1;
inline int PushToUserRepsonse::push_result_list_size() const {
  return push_result_list_.size();
}
inline void PushToUserRepsonse::clear_push_result_list() {
  push_result_list_.Clear();
}
inline const ::Im::Base::PushResult& PushToUserRepsonse::push_result_list(int index) const {
  // @@protoc_insertion_point(field_get:Im.Server.PushToUserRepsonse.push_result_list)
  return push_result_list_.Get(index);
}
inline ::Im::Base::PushResult* PushToUserRepsonse::mutable_push_result_list(int index) {
  // @@protoc_insertion_point(field_mutable:Im.Server.PushToUserRepsonse.push_result_list)
  return push_result_list_.Mutable(index);
}
inline ::Im::Base::PushResult* PushToUserRepsonse::add_push_result_list() {
  // @@protoc_insertion_point(field_add:Im.Server.PushToUserRepsonse.push_result_list)
  return push_result_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Im::Base::PushResult >&
PushToUserRepsonse::push_result_list() const {
  // @@protoc_insertion_point(field_list:Im.Server.PushToUserRepsonse.push_result_list)
  return push_result_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Im::Base::PushResult >*
PushToUserRepsonse::mutable_push_result_list() {
  // @@protoc_insertion_point(field_mutable_list:Im.Server.PushToUserRepsonse.push_result_list)
  return &push_result_list_;
}

// -------------------------------------------------------------------

// GroupGetShieldRequest

// required uint32 group_id = 1;
inline bool GroupGetShieldRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupGetShieldRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupGetShieldRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupGetShieldRequest::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupGetShieldRequest::group_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.GroupGetShieldRequest.group_id)
  return group_id_;
}
inline void GroupGetShieldRequest::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.GroupGetShieldRequest.group_id)
}

// repeated uint32 user_id = 2;
inline int GroupGetShieldRequest::user_id_size() const {
  return user_id_.size();
}
inline void GroupGetShieldRequest::clear_user_id() {
  user_id_.Clear();
}
inline ::google::protobuf::uint32 GroupGetShieldRequest::user_id(int index) const {
  // @@protoc_insertion_point(field_get:Im.Server.GroupGetShieldRequest.user_id)
  return user_id_.Get(index);
}
inline void GroupGetShieldRequest::set_user_id(int index, ::google::protobuf::uint32 value) {
  user_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:Im.Server.GroupGetShieldRequest.user_id)
}
inline void GroupGetShieldRequest::add_user_id(::google::protobuf::uint32 value) {
  user_id_.Add(value);
  // @@protoc_insertion_point(field_add:Im.Server.GroupGetShieldRequest.user_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GroupGetShieldRequest::user_id() const {
  // @@protoc_insertion_point(field_list:Im.Server.GroupGetShieldRequest.user_id)
  return user_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GroupGetShieldRequest::mutable_user_id() {
  // @@protoc_insertion_point(field_mutable_list:Im.Server.GroupGetShieldRequest.user_id)
  return &user_id_;
}

// optional bytes attach_data = 3;
inline bool GroupGetShieldRequest::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupGetShieldRequest::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupGetShieldRequest::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupGetShieldRequest::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& GroupGetShieldRequest::attach_data() const {
  // @@protoc_insertion_point(field_get:Im.Server.GroupGetShieldRequest.attach_data)
  return *attach_data_;
}
inline void GroupGetShieldRequest::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.GroupGetShieldRequest.attach_data)
}
inline void GroupGetShieldRequest::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.GroupGetShieldRequest.attach_data)
}
inline void GroupGetShieldRequest::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.GroupGetShieldRequest.attach_data)
}
inline ::std::string* GroupGetShieldRequest::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.GroupGetShieldRequest.attach_data)
  return attach_data_;
}
inline ::std::string* GroupGetShieldRequest::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupGetShieldRequest::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.GroupGetShieldRequest.attach_data)
}

// -------------------------------------------------------------------

// GroupGetShieldResponse

// required uint32 group_id = 1;
inline bool GroupGetShieldResponse::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupGetShieldResponse::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupGetShieldResponse::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupGetShieldResponse::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupGetShieldResponse::group_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.GroupGetShieldResponse.group_id)
  return group_id_;
}
inline void GroupGetShieldResponse::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.GroupGetShieldResponse.group_id)
}

// repeated .Im.Base.ShieldStatus shield_status_list = 2;
inline int GroupGetShieldResponse::shield_status_list_size() const {
  return shield_status_list_.size();
}
inline void GroupGetShieldResponse::clear_shield_status_list() {
  shield_status_list_.Clear();
}
inline const ::Im::Base::ShieldStatus& GroupGetShieldResponse::shield_status_list(int index) const {
  // @@protoc_insertion_point(field_get:Im.Server.GroupGetShieldResponse.shield_status_list)
  return shield_status_list_.Get(index);
}
inline ::Im::Base::ShieldStatus* GroupGetShieldResponse::mutable_shield_status_list(int index) {
  // @@protoc_insertion_point(field_mutable:Im.Server.GroupGetShieldResponse.shield_status_list)
  return shield_status_list_.Mutable(index);
}
inline ::Im::Base::ShieldStatus* GroupGetShieldResponse::add_shield_status_list() {
  // @@protoc_insertion_point(field_add:Im.Server.GroupGetShieldResponse.shield_status_list)
  return shield_status_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Im::Base::ShieldStatus >&
GroupGetShieldResponse::shield_status_list() const {
  // @@protoc_insertion_point(field_list:Im.Server.GroupGetShieldResponse.shield_status_list)
  return shield_status_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Im::Base::ShieldStatus >*
GroupGetShieldResponse::mutable_shield_status_list() {
  // @@protoc_insertion_point(field_mutable_list:Im.Server.GroupGetShieldResponse.shield_status_list)
  return &shield_status_list_;
}

// optional bytes attach_data = 3;
inline bool GroupGetShieldResponse::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupGetShieldResponse::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupGetShieldResponse::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupGetShieldResponse::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& GroupGetShieldResponse::attach_data() const {
  // @@protoc_insertion_point(field_get:Im.Server.GroupGetShieldResponse.attach_data)
  return *attach_data_;
}
inline void GroupGetShieldResponse::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.GroupGetShieldResponse.attach_data)
}
inline void GroupGetShieldResponse::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.GroupGetShieldResponse.attach_data)
}
inline void GroupGetShieldResponse::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.GroupGetShieldResponse.attach_data)
}
inline ::std::string* GroupGetShieldResponse::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.GroupGetShieldResponse.attach_data)
  return attach_data_;
}
inline ::std::string* GroupGetShieldResponse::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupGetShieldResponse::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.GroupGetShieldResponse.attach_data)
}

// -------------------------------------------------------------------

// FileTransferRequest

// required uint32 from_user_id = 1;
inline bool FileTransferRequest::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileTransferRequest::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileTransferRequest::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileTransferRequest::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 FileTransferRequest::from_user_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferRequest.from_user_id)
  return from_user_id_;
}
inline void FileTransferRequest::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferRequest.from_user_id)
}

// required uint32 to_user_id = 2;
inline bool FileTransferRequest::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileTransferRequest::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileTransferRequest::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileTransferRequest::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 FileTransferRequest::to_user_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferRequest.to_user_id)
  return to_user_id_;
}
inline void FileTransferRequest::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferRequest.to_user_id)
}

// required string file_name = 3;
inline bool FileTransferRequest::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileTransferRequest::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileTransferRequest::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileTransferRequest::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& FileTransferRequest::file_name() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferRequest.file_name)
  return *file_name_;
}
inline void FileTransferRequest::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferRequest.file_name)
}
inline void FileTransferRequest::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.FileTransferRequest.file_name)
}
inline void FileTransferRequest::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.FileTransferRequest.file_name)
}
inline ::std::string* FileTransferRequest::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.FileTransferRequest.file_name)
  return file_name_;
}
inline ::std::string* FileTransferRequest::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FileTransferRequest::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.FileTransferRequest.file_name)
}

// required uint32 file_size = 4;
inline bool FileTransferRequest::has_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileTransferRequest::set_has_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileTransferRequest::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileTransferRequest::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 FileTransferRequest::file_size() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferRequest.file_size)
  return file_size_;
}
inline void FileTransferRequest::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferRequest.file_size)
}

// required .Im.Base.FileType transfer_mode = 5;
inline bool FileTransferRequest::has_transfer_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileTransferRequest::set_has_transfer_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileTransferRequest::clear_has_transfer_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileTransferRequest::clear_transfer_mode() {
  transfer_mode_ = 1;
  clear_has_transfer_mode();
}
inline ::Im::Base::FileType FileTransferRequest::transfer_mode() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferRequest.transfer_mode)
  return static_cast< ::Im::Base::FileType >(transfer_mode_);
}
inline void FileTransferRequest::set_transfer_mode(::Im::Base::FileType value) {
  assert(::Im::Base::FileType_IsValid(value));
  set_has_transfer_mode();
  transfer_mode_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferRequest.transfer_mode)
}

// optional bytes attach_data = 6;
inline bool FileTransferRequest::has_attach_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileTransferRequest::set_has_attach_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileTransferRequest::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileTransferRequest::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& FileTransferRequest::attach_data() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferRequest.attach_data)
  return *attach_data_;
}
inline void FileTransferRequest::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferRequest.attach_data)
}
inline void FileTransferRequest::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.FileTransferRequest.attach_data)
}
inline void FileTransferRequest::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.FileTransferRequest.attach_data)
}
inline ::std::string* FileTransferRequest::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.FileTransferRequest.attach_data)
  return attach_data_;
}
inline ::std::string* FileTransferRequest::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FileTransferRequest::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.FileTransferRequest.attach_data)
}

// -------------------------------------------------------------------

// FileTransferResponse

// required uint32 result_code = 1;
inline bool FileTransferResponse::has_result_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileTransferResponse::set_has_result_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileTransferResponse::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileTransferResponse::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 FileTransferResponse::result_code() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferResponse.result_code)
  return result_code_;
}
inline void FileTransferResponse::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferResponse.result_code)
}

// required uint32 from_user_id = 2;
inline bool FileTransferResponse::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileTransferResponse::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileTransferResponse::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileTransferResponse::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 FileTransferResponse::from_user_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferResponse.from_user_id)
  return from_user_id_;
}
inline void FileTransferResponse::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferResponse.from_user_id)
}

// required uint32 to_user_id = 3;
inline bool FileTransferResponse::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileTransferResponse::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileTransferResponse::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileTransferResponse::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 FileTransferResponse::to_user_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferResponse.to_user_id)
  return to_user_id_;
}
inline void FileTransferResponse::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferResponse.to_user_id)
}

// optional string file_name = 4;
inline bool FileTransferResponse::has_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileTransferResponse::set_has_file_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileTransferResponse::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileTransferResponse::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& FileTransferResponse::file_name() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferResponse.file_name)
  return *file_name_;
}
inline void FileTransferResponse::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferResponse.file_name)
}
inline void FileTransferResponse::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.FileTransferResponse.file_name)
}
inline void FileTransferResponse::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.FileTransferResponse.file_name)
}
inline ::std::string* FileTransferResponse::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.FileTransferResponse.file_name)
  return file_name_;
}
inline ::std::string* FileTransferResponse::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FileTransferResponse::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.FileTransferResponse.file_name)
}

// optional uint32 file_size = 5;
inline bool FileTransferResponse::has_file_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileTransferResponse::set_has_file_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileTransferResponse::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileTransferResponse::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 FileTransferResponse::file_size() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferResponse.file_size)
  return file_size_;
}
inline void FileTransferResponse::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferResponse.file_size)
}

// optional string task_id = 6;
inline bool FileTransferResponse::has_task_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileTransferResponse::set_has_task_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileTransferResponse::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileTransferResponse::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& FileTransferResponse::task_id() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferResponse.task_id)
  return *task_id_;
}
inline void FileTransferResponse::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferResponse.task_id)
}
inline void FileTransferResponse::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.FileTransferResponse.task_id)
}
inline void FileTransferResponse::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.FileTransferResponse.task_id)
}
inline ::std::string* FileTransferResponse::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.FileTransferResponse.task_id)
  return task_id_;
}
inline ::std::string* FileTransferResponse::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FileTransferResponse::set_allocated_task_id(::std::string* task_id) {
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete task_id_;
  }
  if (task_id) {
    set_has_task_id();
    task_id_ = task_id;
  } else {
    clear_has_task_id();
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.FileTransferResponse.task_id)
}

// optional .Im.Base.FileType transfer_mode = 7;
inline bool FileTransferResponse::has_transfer_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FileTransferResponse::set_has_transfer_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FileTransferResponse::clear_has_transfer_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FileTransferResponse::clear_transfer_mode() {
  transfer_mode_ = 1;
  clear_has_transfer_mode();
}
inline ::Im::Base::FileType FileTransferResponse::transfer_mode() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferResponse.transfer_mode)
  return static_cast< ::Im::Base::FileType >(transfer_mode_);
}
inline void FileTransferResponse::set_transfer_mode(::Im::Base::FileType value) {
  assert(::Im::Base::FileType_IsValid(value));
  set_has_transfer_mode();
  transfer_mode_ = value;
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferResponse.transfer_mode)
}

// optional bytes attach_data = 8;
inline bool FileTransferResponse::has_attach_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FileTransferResponse::set_has_attach_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FileTransferResponse::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FileTransferResponse::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& FileTransferResponse::attach_data() const {
  // @@protoc_insertion_point(field_get:Im.Server.FileTransferResponse.attach_data)
  return *attach_data_;
}
inline void FileTransferResponse::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:Im.Server.FileTransferResponse.attach_data)
}
inline void FileTransferResponse::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:Im.Server.FileTransferResponse.attach_data)
}
inline void FileTransferResponse::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Im.Server.FileTransferResponse.attach_data)
}
inline ::std::string* FileTransferResponse::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Im.Server.FileTransferResponse.attach_data)
  return attach_data_;
}
inline ::std::string* FileTransferResponse::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FileTransferResponse::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Im.Server.FileTransferResponse.attach_data)
}

// -------------------------------------------------------------------

// FileServerIpRequest

// -------------------------------------------------------------------

// FileServerIpResponse

// repeated .Im.Base.IpAddr ip_addr_list = 1;
inline int FileServerIpResponse::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline void FileServerIpResponse::clear_ip_addr_list() {
  ip_addr_list_.Clear();
}
inline const ::Im::Base::IpAddr& FileServerIpResponse::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:Im.Server.FileServerIpResponse.ip_addr_list)
  return ip_addr_list_.Get(index);
}
inline ::Im::Base::IpAddr* FileServerIpResponse::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:Im.Server.FileServerIpResponse.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::Im::Base::IpAddr* FileServerIpResponse::add_ip_addr_list() {
  // @@protoc_insertion_point(field_add:Im.Server.FileServerIpResponse.ip_addr_list)
  return ip_addr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Im::Base::IpAddr >&
FileServerIpResponse::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:Im.Server.FileServerIpResponse.ip_addr_list)
  return ip_addr_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Im::Base::IpAddr >*
FileServerIpResponse::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:Im.Server.FileServerIpResponse.ip_addr_list)
  return &ip_addr_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Server
}  // namespace Im

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Im_2eServer_2eproto__INCLUDED
